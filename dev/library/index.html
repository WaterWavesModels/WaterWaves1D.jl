<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · WaterWaves1D.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="WaterWaves1D.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">WaterWaves1D.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><a class="tocitem" href="../problems/">Problems</a></li><li><a class="tocitem" href="../how-to/">How-to...</a></li><li><a class="tocitem" href="../example/">Example</a></li><li><a class="tocitem" href="../plot_recipes/">Plot recipes</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Initial-data"><span>Initial data</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Structures"><span>Structures</span></a></li><li><a class="tocitem" href="#Tools"><span>Tools</span></a></li><li><a class="tocitem" href="#Load-and-save"><span>Load and save</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-(index)"><a class="docs-heading-anchor" href="#Library-(index)">Library (index)</a><a id="Library-(index)-1"></a><a class="docs-heading-anchor-permalink" href="#Library-(index)" title="Permalink"></a></h1><ul><li><a href="#WaterWaves1D.AbstractModel"><code>WaterWaves1D.AbstractModel</code></a></li><li><a href="#WaterWaves1D.Airy"><code>WaterWaves1D.Airy</code></a></li><li><a href="#WaterWaves1D.AkersNicholls"><code>WaterWaves1D.AkersNicholls</code></a></li><li><a href="#WaterWaves1D.AkersNicholls_fast"><code>WaterWaves1D.AkersNicholls_fast</code></a></li><li><a href="#WaterWaves1D.Boussinesq"><code>WaterWaves1D.Boussinesq</code></a></li><li><a href="#WaterWaves1D.CnoidalSGN"><code>WaterWaves1D.CnoidalSGN</code></a></li><li><a href="#WaterWaves1D.Data"><code>WaterWaves1D.Data</code></a></li><li><a href="#WaterWaves1D.Euler"><code>WaterWaves1D.Euler</code></a></li><li><a href="#WaterWaves1D.EulerSymp"><code>WaterWaves1D.EulerSymp</code></a></li><li><a href="#WaterWaves1D.Euler_naive"><code>WaterWaves1D.Euler_naive</code></a></li><li><a href="#WaterWaves1D.Init"><code>WaterWaves1D.Init</code></a></li><li><a href="#WaterWaves1D.InitialData"><code>WaterWaves1D.InitialData</code></a></li><li><a href="#WaterWaves1D.IsobeKakinuma"><code>WaterWaves1D.IsobeKakinuma</code></a></li><li><a href="#WaterWaves1D.Matsuno"><code>WaterWaves1D.Matsuno</code></a></li><li><a href="#WaterWaves1D.Matsuno_fast"><code>WaterWaves1D.Matsuno_fast</code></a></li><li><a href="#WaterWaves1D.Mesh"><code>WaterWaves1D.Mesh</code></a></li><li><a href="#WaterWaves1D.NonHydrostatic"><code>WaterWaves1D.NonHydrostatic</code></a></li><li><a href="#WaterWaves1D.Problem"><code>WaterWaves1D.Problem</code></a></li><li><a href="#WaterWaves1D.RK4"><code>WaterWaves1D.RK4</code></a></li><li><a href="#WaterWaves1D.RK4_naive"><code>WaterWaves1D.RK4_naive</code></a></li><li><a href="#WaterWaves1D.Random"><code>WaterWaves1D.Random</code></a></li><li><a href="#WaterWaves1D.SaintVenant"><code>WaterWaves1D.SaintVenant</code></a></li><li><a href="#WaterWaves1D.SerreGreenNaghdi"><code>WaterWaves1D.SerreGreenNaghdi</code></a></li><li><a href="#WaterWaves1D.SolitarySGN"><code>WaterWaves1D.SolitarySGN</code></a></li><li><a href="#WaterWaves1D.SolitaryWB"><code>WaterWaves1D.SolitaryWB</code></a></li><li><a href="#WaterWaves1D.SolitaryWGN"><code>WaterWaves1D.SolitaryWGN</code></a></li><li><a href="#WaterWaves1D.SolitaryWhitham"><code>WaterWaves1D.SolitaryWhitham</code></a></li><li><a href="#WaterWaves1D.SquareRootDepth"><code>WaterWaves1D.SquareRootDepth</code></a></li><li><a href="#WaterWaves1D.Times"><code>WaterWaves1D.Times</code></a></li><li><a href="#WaterWaves1D.WWn"><code>WaterWaves1D.WWn</code></a></li><li><a href="#WaterWaves1D.WaterWaves"><code>WaterWaves1D.WaterWaves</code></a></li><li><a href="#WaterWaves1D.WhithamBoussinesq"><code>WaterWaves1D.WhithamBoussinesq</code></a></li><li><a href="#WaterWaves1D.WhithamGreenNaghdi"><code>WaterWaves1D.WhithamGreenNaghdi</code></a></li><li><a href="#WaterWaves1D.modifiedMatsuno"><code>WaterWaves1D.modifiedMatsuno</code></a></li><li><a href="#Base.dump-Tuple{String, Data}"><code>Base.dump</code></a></li><li><a href="#Base.dump-Tuple{String, Vector, InitialData}"><code>Base.dump</code></a></li><li><a href="#Base.dump-Tuple{String, Problem}"><code>Base.dump</code></a></li><li><a href="#WaterWaves1D.CnoidalWaveSerreGreenNaghdi-Tuple{NamedTuple}"><code>WaterWaves1D.CnoidalWaveSerreGreenNaghdi</code></a></li><li><a href="#WaterWaves1D.SolitaryWaveSerreGreenNaghdi-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveSerreGreenNaghdi</code></a></li><li><a href="#WaterWaves1D.SolitaryWaveWhitham-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveWhitham</code></a></li><li><a href="#WaterWaves1D.SolitaryWaveWhithamBoussinesq-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveWhithamBoussinesq</code></a></li><li><a href="#WaterWaves1D.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveWhithamGreenNaghdi</code></a></li><li><a href="#WaterWaves1D.energy-Tuple{Problem}"><code>WaterWaves1D.energy</code></a></li><li><a href="#WaterWaves1D.energydiff-Tuple{Problem}"><code>WaterWaves1D.energydiff</code></a></li><li><a href="#WaterWaves1D.interpolate-Tuple{Mesh, Any}"><code>WaterWaves1D.interpolate</code></a></li><li><a href="#WaterWaves1D.interpolate-Tuple{Mesh, Any, Any}"><code>WaterWaves1D.interpolate</code></a></li><li><a href="#WaterWaves1D.load_data-Tuple{String}"><code>WaterWaves1D.load_data</code></a></li><li><a href="#WaterWaves1D.load_data!-Tuple{String, Problem}"><code>WaterWaves1D.load_data!</code></a></li><li><a href="#WaterWaves1D.load_init-Tuple{String}"><code>WaterWaves1D.load_init</code></a></li><li><a href="#WaterWaves1D.mass-Tuple{Problem}"><code>WaterWaves1D.mass</code></a></li><li><a href="#WaterWaves1D.massdiff-Tuple{Problem}"><code>WaterWaves1D.massdiff</code></a></li><li><a href="#WaterWaves1D.momentum-Tuple{Problem}"><code>WaterWaves1D.momentum</code></a></li><li><a href="#WaterWaves1D.momentumdiff-Tuple{Problem}"><code>WaterWaves1D.momentumdiff</code></a></li><li><a href="#WaterWaves1D.random-Tuple{Any}"><code>WaterWaves1D.random</code></a></li><li><a href="#WaterWaves1D.solution-Tuple{Problem}"><code>WaterWaves1D.solution</code></a></li><li><a href="#WaterWaves1D.solve!-Tuple{Any}"><code>WaterWaves1D.solve!</code></a></li><li><a href="#WaterWaves1D.solve!-Tuple{Problem}"><code>WaterWaves1D.solve!</code></a></li></ul><h2 id="Initial-data"><a class="docs-heading-anchor" href="#Initial-data">Initial data</a><a id="Initial-data-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-data" title="Permalink"></a></h2><ul></ul><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.CnoidalSGN" href="#WaterWaves1D.CnoidalSGN"><code>WaterWaves1D.CnoidalSGN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CnoidalSGN(param; P=1)</code></pre><p>Build the initial data associated with <code>CnoidalWaveSerreGreenNaghdi(param; P=1)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/CnoidalWaveSerreGreenNaghdi.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.CnoidalWaveSerreGreenNaghdi-Tuple{NamedTuple}" href="#WaterWaves1D.CnoidalWaveSerreGreenNaghdi-Tuple{NamedTuple}"><code>WaterWaves1D.CnoidalWaveSerreGreenNaghdi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CnoidalWaveSerreGreenNaghdi(param; P=1)</code></pre><p>Compute the Serre-Green-Naghdi cnoidal wave with prescribed <code>h₀&lt;h₁&lt;h₂</code>. <code>h₁</code> is the minimum, <code>h₂</code> is the maximum of the wave. As <code>h₀ -&gt; h₁</code>, the cnoidal wave converges towards the solitary wave. See for instance <a href="https://doi.org/10.1088/1361-6544/ab95ac">Gavrilyuk, Nkonga, Shyue and Truskinovsky</a>.</p><p><strong>Arguments</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing <code>h₀&lt;h₁&lt;h₂</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>.</li><li><code>P :: Int</code>: (keyword, optional, default = 1) the number of periods of the cnoidal wave in the constructed mesh.</li></ul><p><strong>Return values</strong></p><p><code>(η,u,v,mesh,param)</code> with</p><ul><li><code>η :: Vector{Float64}</code>: surface deformation;</li><li><code>u :: Vector{Float64}</code>: layer-averaged velocity;</li><li><code>v :: Vector{Float64}</code>: derivative of the trace of the velocity potential at the surface;</li><li><code>mesh :: Mesh</code>: mesh collocation points;</li><li><code>param :: NamedTuple</code>: useful parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/CnoidalWaveSerreGreenNaghdi.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitarySGN" href="#WaterWaves1D.SolitarySGN"><code>WaterWaves1D.SolitarySGN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolitarySGN(param; x₀=0)</code></pre><p>Build the initial data associated with <code>SolitaryWaveSerreGreenNaghdi(param; x₀=0)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p><hr/><pre><code class="nohighlight hljs">SolitarySGN(c; ϵ=1,μ=1,x₀=0,N=2^12)</code></pre><p>Build the initial data with velocity <code>c</code>, center <code>x₀</code>, dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/SolitaryWaveSerreGreenNaghdi.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWaveSerreGreenNaghdi-Tuple{NamedTuple}" href="#WaterWaves1D.SolitaryWaveSerreGreenNaghdi-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveSerreGreenNaghdi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SolitaryWaveSerreGreenNaghdi(param; x₀=0)</code></pre><p>Compute the Serre-Green-Naghdi solitary wave with prescribed velocity.</p><p><strong>Arguments</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing velocity <code>c</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>, and mesh size <code>L</code> and number of collocation points <code>N</code>;</li><li><code>x₀ :: Real</code>: (keyword, optional, default = 0) center of solitary wave.</li></ul><p><strong>Return values</strong></p><p><code>(η,u,v,mesh)</code> with</p><ul><li><code>η :: Vector{Float64}</code>: surface deformation;</li><li><code>u :: Vector{Float64}</code>: layer-averaged velocity;</li><li><code>v :: Vector{Float64}</code>: derivative of the trace of the velocity potential at the surface;</li><li><code>mesh :: Mesh</code>: mesh collocation points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/SolitaryWaveSerreGreenNaghdi.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWGN" href="#WaterWaves1D.SolitaryWGN"><code>WaterWaves1D.SolitaryWGN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolitaryWGN(param; kwargs)</code></pre><p>Build the initial data associated with <code>SolitaryWaveWhithamGreenNaghdi(param; kwargs)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p><hr/><pre><code class="nohighlight hljs">SolitaryWGN(c; ϵ=1,μ=1,N=2^12,kwargs)</code></pre><p>Build the initial data with velocity <code>c</code>, dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>, and <code>kwargs</code> the other (optional) keyword arguments as above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/SolitaryWaveWhithamGreenNaghdi.jl#L290-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple}" href="#WaterWaves1D.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveWhithamGreenNaghdi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SolitaryWaveWhithamGreenNaghdi(param; kwargs)</code></pre><p>Compute the Whitham-Green-Naghdi solitary wave with prescribed velocity.</p><p><strong>Arguments</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing velocity <code>c</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>, and mesh size <code>L</code> and number of collocation points <code>N</code>;</li></ul><p><strong>Keywords (optional)</strong></p><ul><li><code>guess :: Vector{Real}</code>: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);</li><li><code>x₀ :: Real</code>: center of solitary wave (if guess is not provided);</li><li><code>SGN :: Bool</code>: if <code>true</code> computes the Serre-Green-Naghdi (instead of Whitham-Green-Naghdi) solitary wave (consider <code>SolitaryWaveSerreGreenNaghdi</code> instead);</li><li><code>method :: Int</code>: equation used (between <code>1</code> and <code>4</code>);</li><li><code>iterative :: Bool</code>: inverts Jacobian through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>false</code>);</li><li><code>verbose :: Bool</code>: prints numerical errors at each step if <code>true</code> (default is <code>false</code>);</li><li><code>max_iter :: Int</code>: maximum number of iterations of the Newton algorithm (default is <code>20</code>);</li><li><code>tol :: Real</code>: relative tolerance measured in ℓ∞ norm (default is <code>1e-10</code>);</li><li><code>ktol :: Real</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>gtol :: Real</code>: relative tolerance of the GMRES algorithm (default is <code>1e-10</code>);</li><li><code>dealias :: Int</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>q :: Real</code>: Newton algorithm modified with <code>u_{n+1}=q*u_{n+1}+(1-q)*u_n</code> (default is <code>1</code>);</li><li><code>α :: Real</code>: adds <code>α</code> times spectral projection onto the Kernel to the Jacobian (default is <code>0</code>).</li></ul><p><strong>Return values</strong></p><p><code>(η,u,v,mesh)</code> with</p><ul><li><code>η :: Vector{Float64}</code>: surface deformation;</li><li><code>u :: Vector{Float64}</code>: layer-averaged velocity;</li><li><code>v :: Vector{Float64}</code>: derivative of the velocity potential at the surface;</li><li><code>mesh :: Mesh</code>: mesh collocation points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/SolitaryWaveWhithamGreenNaghdi.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWB" href="#WaterWaves1D.SolitaryWB"><code>WaterWaves1D.SolitaryWB</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolitaryWB(param; kwargs)</code></pre><p>Build the initial data associated with <code>SolitaryWaveWhithamBoussinesq(param; kwargs)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p><hr/><pre><code class="nohighlight hljs">SolitaryWB(c; ϵ=1,μ=1,N=2^12,kwargs)</code></pre><p>Build the initial data with velocity <code>c</code>, dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>, and <code>kwargs</code> the other (optional) keyword arguments as above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/SolitaryWaveWhithamBoussinesq.jl#L170-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWaveWhithamBoussinesq-Tuple{NamedTuple}" href="#WaterWaves1D.SolitaryWaveWhithamBoussinesq-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveWhithamBoussinesq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SolitaryWaveWhithamBoussinesq(param; kwargs)</code></pre><p>Compute the Whitham-Boussinesq solitary wave with prescribed velocity.</p><p><strong>Argument</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing velocity <code>c</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>,</li></ul><p>and mesh size <code>L</code> and number of collocation points <code>N</code>;</p><p><strong>Keywords (optional)</strong></p><ul><li><code>guess :: Vector{Real}</code>: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);</li><li><code>x₀ :: Real</code>: center of solitary wave (if guess is not provided);</li><li><code>α :: Real</code>: determines the model used (typically <code>1</code> or <code>1/2</code>, default is 1);</li><li><code>Boussinesq</code>: if <code>true</code> (default is <code>false</code>), compute the standard Boussinesq system with parameters <code>a</code> (defaut <code>-1//3</code>), <code>b=d</code> (defaut <code>1//3</code>), and <code>c=0</code>);</li><li><code>iterative :: Bool</code>: inverts Jacobian through GMRES if <code>true</code>, LU decomposition if <code>false</code>;</li><li><code>verbose :: Bool</code>: prints numerical errors at each step if <code>true</code>;</li><li><code>max_iter :: Int</code>: maximum number of iterations of the Newton algorithm;</li><li><code>tol :: Real</code>: general tolerance (default is <code>1e-10</code>);</li><li><code>ktol :: Real</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>gtol :: Real</code>: relative tolerance of the GMRES algorithm (default is <code>1e-10</code>);</li><li><code>dealias :: Int</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>q :: Real</code>: Newton algorithm modified with</li></ul><p><code>u_{n+1}=q*(u_n+du)+(1-q)*u_n</code> (default is <code>1</code>);</p><ul><li><code>β :: Real</code>: adds <code>β</code> times spectral projection onto the Kernel to the Jacobian.β</li></ul><p><strong>Return values</strong></p><p><code>(η,v,mesh)</code> with</p><ul><li><code>η :: Vector{Float64}</code>: surface deformation;</li><li><code>v :: Vector{Float64}</code>: velocity (derivative of the trace of the velocity potential at the surface);</li><li><code>mesh :: Mesh</code>: mesh collocation points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/SolitaryWaveWhithamBoussinesq.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWhitham" href="#WaterWaves1D.SolitaryWhitham"><code>WaterWaves1D.SolitaryWhitham</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolitaryWhitham(param; kwargs)</code></pre><p>Build the initial data associated with <code>SolitaryWaveWhitham(param; kwargs)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p><hr/><pre><code class="nohighlight hljs">SolitaryWhitham(c; ϵ=1,μ=1,N=2^12,kwargs)</code></pre><p>Build the initial data with velocity <code>c</code>, dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>, and <code>kwargs</code> the other (optional) keyword arguments as above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/SolitaryWaveWhitham.jl#L150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWaveWhitham-Tuple{NamedTuple}" href="#WaterWaves1D.SolitaryWaveWhitham-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveWhitham</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SolitaryWaveWhitham(param; kwargs)</code></pre><p>Compute the Whitham solitary wave with prescribed velocity.</p><p><strong>Argument</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing velocity <code>c</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>, and mesh size <code>L</code> and number of collocation points <code>N</code>;</li></ul><p><strong>Keywords (optional)</strong></p><ul><li><code>guess :: Vector{Real}</code>: initial guess for the surface deformation (if not provided, the exact formula for KdV is used);</li><li><code>x₀ :: Real</code>: center of solitary wave (if guess is not provided);</li><li><code>iterative :: Bool</code>: inverts Jacobian through GMRES if <code>true</code>, LU decomposition if <code>false</code>;</li><li><code>verbose :: Bool</code>: prints numerical errors at each step if <code>true</code>;</li><li><code>max_iter :: Int</code>: maximum number of iterations of the Newton algorithm;</li><li><code>tol :: Real</code>: general tolerance (default is <code>1e-10</code>);</li><li><code>ktol :: Real</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>gtol :: Real</code>: relative tolerance of the GMRES algorithm (default is <code>1e-10</code>);</li><li><code>dealias :: Int</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>q :: Real</code>: Newton algorithm modified with</li></ul><p><code>u_{n+1}=q*u_{n+1}+(1-q)*u_n</code> (default is <code>1</code>);</p><ul><li><code>α :: Real</code>: adds <code>α</code> times spectral projection onto the Kernel to the Jacobian;</li><li><code>KdV :: Bool</code>: if <code>true</code> computes the KdV (instead of Whitham) solitary wave.</li></ul><p><strong>Return values</strong></p><p><code>(u,mesh)</code> with</p><ul><li><code>u :: Vector{Float64}</code>: the solution;</li><li><code>mesh :: Mesh</code>: mesh collocation points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/SolitaryWaveWhitham.jl#L3-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Random" href="#WaterWaves1D.Random"><code>WaterWaves1D.Random</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Random(param;args)</code></pre><p>Randomly generated initial data, based on provided (optional arguments) :</p><ul><li><code>L</code> is the typical wavelength (default is <code>L=1</code>),</li><li><code>s</code> is the (real) Sobolev index regularity (default is <code>s=∞</code>),</li><li><code>λ</code> is the length of spatial localization (default is <code>λ=∞</code>, no localization),</li><li><code>a</code> is the couple of amplitudes of the surface deformation, and velocity (default is <code>a=(1,1)</code>).</li></ul><p>Return an initial data <code>init::InitialData</code>,  to be used in initial-value problems <code>Problem(model, init, param)</code>, with <code>init.η</code> and <code>init.v</code> two samples of <code>random(x;L,s,λ)</code>, where <code>x</code> is the set of collocation points generated by <code>Mesh(param)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/Random.jl#L40-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.random-Tuple{Any}" href="#WaterWaves1D.random-Tuple{Any}"><code>WaterWaves1D.random</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random(x;args)</code></pre><p>Randomly generate a vector of size <code>x</code>, based on provided (optional arguments) :</p><ul><li><code>L</code> is the typical wavelength (default is <code>L=1</code>),</li><li><code>s</code> is the (real) Sobolev index regularity (default is <code>s=∞</code>, smooth data),</li><li><code>λ</code> is the length of spatial localization (default is <code>λ=∞</code>, no localization),</li><li><code>a</code> is the amplitude of the returned vector (default is <code>a=1</code>).</li></ul><p>The vector is generated through randomly chosen Fourier coefficients, multiplied with weigth <code>w=10^(-|k|L/(2π))</code> if <code>s=∞</code>, or <code>w=1/(1+9(|k|L/(2π))^(s+1/2))</code> otherwise. If <code>λ≠∞</code>, the function in spatial variables is multiplied by <code>exp(-|x/λ|^2)</code>, and in any case normalized to have maximum absolute value 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/initialdata/Random.jl#L2-L17">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><ul></ul><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.AbstractModel" href="#WaterWaves1D.AbstractModel"><code>WaterWaves1D.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type whose subtypes are the models from which initial-value problems can be built, through <code>Problem( model :: AbstractModel, initial :: InitialData, param :: NamedTuple )</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Airy" href="#WaterWaves1D.Airy"><code>WaterWaves1D.Airy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Airy(param;mesh,label)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the linear (<a href="https://en.wikipedia.org/wiki/Airy_wave_theory">Airy</a>) water waves equations.</p><p><strong>Arguments</strong></p><ul><li><code>param::NamedTuple</code> must contain<ul><li>the shallowness parameter <code>μ</code> (set the infinite-layer case if <code>μ=Inf</code>);</li><li>optionally, <code>ν</code> the shallow/deep water scaling factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise;</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided.</li></ul></li><li><code>mesh  :: Mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>.</li><li><code>label :: String</code>: a label for future references (default is <code>&quot;linear (Airy)&quot;</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>Airy.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>Airy.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>Airy.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/Airy.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.AkersNicholls" href="#WaterWaves1D.AkersNicholls"><code>WaterWaves1D.AkersNicholls</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AkersNicholls(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the quadratic deep-water model proposed by <a href="https://doi.org/10.1137/090771351">Akers and Nicholls</a> and <a href="https://doi.org/10.1007/s42286-019-00005-w">Cheng, Granero-Belinchón, Shkoller and Milewski</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>optionally, <code>ν</code> the shallow/deep water scaling factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise. Set the infinite-layer case if <code>ν=0</code>, or <code>μ=Inf</code>.</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>dealias</code>: dealiasing with <code>1/3</code> Orlicz rule if <code>true</code> or no dealiasing if <code>false</code> (by default);</li><li><code>label</code>: a label for future references (default is <code>&quot;deep quadratic&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>AkersNicholls.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>AkersNicholls.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>AkersNicholls.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/AkersNicholls.jl#L144-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.AkersNicholls_fast" href="#WaterWaves1D.AkersNicholls_fast"><code>WaterWaves1D.AkersNicholls_fast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AkersNicholls_fast(param;kwargs)</code></pre><p>Same as <code>AkersNicholls</code>, but faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/AkersNicholls.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Boussinesq" href="#WaterWaves1D.Boussinesq"><code>WaterWaves1D.Boussinesq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Boussinesq(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for <code>abcd</code>-Boussinesq models (with <code>b=d</code> and <code>c=0</code>). See <a href="https://doi.org/10.1007/s00332-002-0466-4">Bona, Chen, and Saut</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li>two parameters <code>a</code> (default is <code>-1/3</code>) and <code>b</code> (default is <code>+1/3</code>) which determine the model solved. You need <code>a+2*b=1/3</code> for validity as a long wave model (without surface tension).</li><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Boussinesq&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>Boussinesq.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>Boussinesq.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>Boussinesq.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/Boussinesq.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.IsobeKakinuma" href="#WaterWaves1D.IsobeKakinuma"><code>WaterWaves1D.IsobeKakinuma</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsobeKakinuma(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the Isobe-Kakinuma model proposed by <a href="https://doi.org/10.1061/9780784400890.023">Isobe</a>.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> (or a collection <code>NamedTuple</code>s) of and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Isobe-Kakinuma&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>IsobeKakinuma.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>IsobeKakinuma.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>IsobeKakinuma.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/IsobeKakinuma.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Matsuno" href="#WaterWaves1D.Matsuno"><code>WaterWaves1D.Matsuno</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matsuno(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the quadratic deep-water model proposed by <a href="https://doi.org/10.1103/PhysRevLett.69.609">Matsuno</a>.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>optionally, <code>ν</code> the shallow/deep water scaling factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise. Set the infinite-layer case if <code>ν=0</code>, or <code>μ=Inf</code>.</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>dealias</code>: dealiasing with <code>1/3</code> Orlicz rule if <code>true</code> or no dealiasing if <code>false</code> (by default);</li><li><code>label</code>: a label for future references (default is <code>&quot;Matsuno&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>Matsuno.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>Matsuno.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>Matsuno.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/Matsuno.jl#L175-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Matsuno_fast" href="#WaterWaves1D.Matsuno_fast"><code>WaterWaves1D.Matsuno_fast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matsuno_fast(param;kwargs)</code></pre><p>Same as <code>Matsuno</code>, but faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/Matsuno.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.NonHydrostatic" href="#WaterWaves1D.NonHydrostatic"><code>WaterWaves1D.NonHydrostatic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonHydrostatic(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the &quot;Non-hydrostatic&quot; model proposed by <a href="https://doi.org/10.3934/dcdsb.2015.20.961">Bristeau, Mangeney, Sainte-Marie and Seguin</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;non-hydrostatic&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>NonHydrostatic.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>NonHydrostatic.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>NonHydrostatic.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>;</li></ul></li><li>additionally, a handy function <code>NonHydrostatic.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/NonHydrostatic.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SaintVenant" href="#WaterWaves1D.SaintVenant"><code>WaterWaves1D.SaintVenant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SaintVenant(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for Saint-Venant (or shallow water) model.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>the dimensionless parameter <code>ϵ</code> (nonlinearity);</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Saint-Venant&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>SaintVenant.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>SaintVenant.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>SaintVenant.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/SaintVenant.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SerreGreenNaghdi" href="#WaterWaves1D.SerreGreenNaghdi"><code>WaterWaves1D.SerreGreenNaghdi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SerreGreenNaghdi(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the Serre-Green-Naghdi model (<a href="https://10.1051/lhb/1953058">Serre</a>, <a href="https://10.1063/1.1664873">Su and Gardner</a>, <a href="https://10.1017/s0022112076002425">Green and Naghdi</a>).</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Green-Naghdi&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>SerreGreenNaghdi.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>SerreGreenNaghdi.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>SerreGreenNaghdi.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>;</li></ul></li><li>additionally, a handy function <code>SerreGreenNaghdi.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/SerreGreenNaghdi.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SquareRootDepth" href="#WaterWaves1D.SquareRootDepth"><code>WaterWaves1D.SquareRootDepth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SquareRootDepth(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the &quot;√D&quot; model proposed by <a href="https://doi.org/10.1098/rspa.2010.0124">Cotter, Holm and Percival</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;square-root depth&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>SquareRootDepth.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>SquareRootDepth.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>SquareRootDepth.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>;</li></ul></li><li>additionally, a handy function <code>SquareRootDepth.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/SquareRootDepth.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WWn" href="#WaterWaves1D.WWn"><code>WaterWaves1D.WWn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WWn(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the water waves expansion proposed by <a href="https://doi.org/10.1017/s002211208700288x">Dommermuth and Yue</a>, <a href="https://doi.org/10.1029/jc092ic11p11803">West et al.</a>, <a href="https://doi.org/10.1006/jcph.1993.1164">Craig and Sulem</a> (see also the account by <a href="http://hdl.handle.net/2433/251940">Choi</a>) with the &quot;rectification&quot; method proposed by <a href="https://arxiv.org/abs/2203.03277">Duchêne and Melinand</a>.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>optionally, <code>ν</code> the shallow/deep water scaling factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise. Set the infinite-layer case if <code>ν=0</code>, or <code>μ=Inf</code>.</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>n :: Int</code>: the order of the expansion; linear system if <code>1</code>, quadratic if <code>2</code>, cubic if <code>3</code>, quartic if <code>4</code> (default and other values yield <code>2</code>);</li><li><code>δ</code> and <code>m</code>: parameters of the rectifier operator, set as <code>k-&gt;min(1,|δ*k|^m)</code> or <code>k-&gt;min(1,|δ*k|^m[1]*exp(1-|δ*k|^m[2]))</code> if <code>m</code> is a couple</li></ul><p>(by default is <code>δ=0</code>, i.e. no regularization and <code>m=-1</code>. Notice <code>m=-Inf</code> and <code>δ&gt;0</code> yields a cut-off filter);</p><ul><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;WWn&quot;</code> with <code>n</code> the order of the expansion);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WWn.f!</code> to be called in explicit time-integration solvers (also <code>WWn.f1!</code> and <code>WWn.f2!</code> for the symplectic Euler solver);</li><li>a function <code>WWn.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>WWn.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where</li></ol><pre><code class="nohighlight hljs">- `η` is the values of surface deformation at collocation points `x`;
- `v` is the derivative of the trace of the velocity potential at `x`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/WWn.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WaterWaves" href="#WaterWaves1D.WaterWaves"><code>WaterWaves1D.WaterWaves</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaterWaves(param; kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the water waves system (via conformal mapping, see <a href="https://doi.org/10.1016/S0997-7546(02)01189-5">Zakharov, Dyachenko and Vasilyev</a>).</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>optionally, <code>ν</code> the shallow/deep water scaling factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise. Set the infinite-layer case if <code>ν=0</code>, or <code>μ=Inf</code>.</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code>, in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>method ∈ {1,2,3}</code>: method used to initialize the conformal mapping, as a fix-point problem <code>F(u)=u</code><ul><li>if <code>method == 1</code>, use standard contraction fix-point iteration;</li><li>if <code>method == 2</code>, use Newton algorithm with GMRES iterative solver to invert the Jacobian;</li><li>if <code>method == 3</code>, use Newton algorithm with direct solver to invert the Jacobian;</li></ul></li><li><code>tol</code>: (relative) tolerance of the fix-point algorithm (default is <code>1e-16</code>);</li><li><code>maxiter</code>: the maximal number of iteration in the fix-point algorithm (default is <code>100</code>);</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;water waves&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WaterWaves.f!</code> to be called in the explicit time-integration solver (also <code>WaterWaves.f1!</code> and <code>WaterWaves.f2!</code> for the symplectic Euler solver);</li><li>a function <code>WaterWaves.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>WaterWaves.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>x</code> is a vector of collocation points (non-regularly spaced);</li></ul></li></ol><pre><code class="nohighlight hljs">- `η` is the values of surface deformation at collocation points `x`;
- `v` is the derivative of the trace of the velocity potential at `x`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/WaterWaves.jl#L3-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WhithamBoussinesq" href="#WaterWaves1D.WhithamBoussinesq"><code>WaterWaves1D.WhithamBoussinesq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WhithamBoussinesq(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for a Boussinesq-type model with full-dispersion property.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>Boussinesq</code>: if <code>true</code> (default is <code>false</code>), compute the standard Boussinesq system instead (see <code>Boussinesq(param;kwargs)</code>);</li><li>a parameter <code>α</code> which determines the model solved:<ul><li>If <code>α = 1</code> (default), then the model has been introduced in <a href="https://doi.org/10.1016/j.apnum.2018.09.016">Dinvay, Dutykh and Kalisch</a>;</li><li>If <code>α = 1/2</code>, then the model is a quasilinear version;</li><li>If <code>α &lt; 1/2</code>, then expect instabilities stemming from ill-posedness of the model.</li></ul></li><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Whitham-Boussinesq&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WhithamBoussinesq.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>WhithamBoussinesq.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed.</li><li>a function <code>WhithamBoussinesq.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where</li></ol><pre><code class="nohighlight hljs">- `η` is the values of surface deformation at collocation points `x`;
- `v` is the derivative of the trace of the velocity potential at `x`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/WhithamBoussinesq.jl#L3-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WhithamGreenNaghdi" href="#WaterWaves1D.WhithamGreenNaghdi"><code>WaterWaves1D.WhithamGreenNaghdi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WhithamGreenNaghdi(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the fully dispersive Green-Naghdi model proposed by <a href="https://doi.org/10.1137/130947064">Duchêne, Israwi and Talhouk</a>.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>SGN</code>: if <code>true</code> (default is <code>false</code>), compute the Serre-Green-Naghdi (SGN) instead of Whitham-Green-Naghdi (WGN) system (see <code>SerreGreenNaghdi(param;kwargs)</code>);</li><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Whitham-Green-Naghdi&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WhithamGreenNaghdi.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>WhithamGreenNaghdi.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>WhithamGreenNaghdi.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where</li></ol><pre><code class="nohighlight hljs">- `η` is the values of surface deformation at collocation points `x`;
- `v` is the derivative of the trace of the velocity potential at `x`;</code></pre><ol><li>additionally, a handy function <code>WhithamGreenNaghdi.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/WhithamGreenNaghdi.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.modifiedMatsuno" href="#WaterWaves1D.modifiedMatsuno"><code>WaterWaves1D.modifiedMatsuno</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">modifiedMatsuno(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the modified Matsuno model proposed by <a href="https://arxiv.org/abs/2203.03277">Duchêne and Melinand</a>.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>optionally, <code>ν</code> the shallow/deep water scaling factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise. Set the infinite-layer case if <code>ν=0</code>, or <code>μ=Inf</code>.</li><li>numerical parameters to construct the mesh of collocation points, if <code>mesh</code> is not provided as a keyword argument.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>mesh</code>: the mesh of collocation points. By default, <code>mesh = Mesh(param)</code>;</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;modified Matsuno&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>modifiedMatsuno.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>modifiedMatsuno.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>modifiedMatsuno.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v,x)</code>, where<ul><li><code>η</code> is the values of surface deformation at collocation points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at <code>x</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/models/modifiedMatsuno.jl#L3-L30">source</a></section></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><ul></ul><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Euler" href="#WaterWaves1D.Euler"><code>WaterWaves1D.Euler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Euler(arguments;realdata)</code></pre><p>Explicit Euler solver.</p><p>Construct an object of type <code>TimeSolver</code> to be used in <code>Problem(model, initial, param; solver::TimeSolver)</code></p><p>Arguments can be either</p><ol><li>an object of type <code>AbstractModel</code>;</li><li>an <code>Array</code> of size <code>(N,datasize)</code> where <code>N</code> is the number of collocation points and <code>datasize</code> the number of equations solved;</li><li><code>(param,datasize)</code> where <code>param is a</code>NamedTuple<code>containing a key</code>N<code>, and</code>datasize<code>a integer (optional, by default</code>datasize=2`).</li></ol><p>The keyword argument <code>realdata</code> is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case <code>0.</code> and <code>1.</code>, complex-valued in case <code>2.</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/solvers/Euler.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.EulerSymp" href="#WaterWaves1D.EulerSymp"><code>WaterWaves1D.EulerSymp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EulerSymp(arguments;Niter,implicit,realdata)</code></pre><p>Symplectic Euler solver. The implicit Euler method is first used on one equation, then the explicit Euler method is used on the second one. The implicit equation is solved via Neumann iteration</p><p>Construct an object of type <code>TimeSolver</code> to be used in <code>Problem(model, initial, param; solver::TimeSolver)</code></p><p>Arguments can be either</p><ol><li>an object of type <code>AbstractModel</code>;</li><li>an <code>Array</code> of size <code>(N,2)</code> where <code>N</code> is the number of collocation points;</li><li>a <code>NamedTuple</code> containing a key <code>N</code>.</li></ol><p>The keyword argument <code>Niter</code> (optional, defaut value = 10) determines the number of steps in the Neumann iteration solver of the implicit step. The keyword argument <code>implicit</code> (optional, defaut value = 1) determines which equation is implicit (must be <code>1</code> or <code>2</code>). The keyword argument <code>realdata</code> is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case <code>0.</code> and <code>1.</code>, complex-valued in case <code>2.</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/solvers/EulerSymp.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Euler_naive" href="#WaterWaves1D.Euler_naive"><code>WaterWaves1D.Euler_naive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Euler_naive()</code></pre><p>Runge-Kutta fourth order solver.</p><p>A naive version of <code>Euler</code>, without argument since no pre-allocation is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/solvers/Euler.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.RK4" href="#WaterWaves1D.RK4"><code>WaterWaves1D.RK4</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RK4(arguments;realdata)</code></pre><p>Explicit Runge-Kutta fourth order solver.</p><p>Construct an object of type <code>TimeSolver</code> to be used in <code>Problem(model, initial, param; solver::TimeSolver)</code></p><p>Arguments can be either</p><ol><li>an object of type <code>AbstractModel</code>;</li><li>an <code>Array</code> of size <code>(N,datasize)</code> where <code>N</code> is the number of collocation points and <code>datasize</code> the number of equations solved;</li><li><code>(param,datasize)</code> where <code>param is a</code>NamedTuple<code>containing a key</code>N<code>, and</code>datasize<code>a integer (optional, by default</code>datasize=2`).</li></ol><p>The keyword argument <code>realdata</code> is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case <code>0.</code> and <code>1.</code>, complex-valued in case <code>2.</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/solvers/RK4.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.RK4_naive" href="#WaterWaves1D.RK4_naive"><code>WaterWaves1D.RK4_naive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RK4_naive()</code></pre><p>Runge-Kutta fourth order solver.</p><p>A naive version of <code>RK4</code>, without argument since no pre-allocation is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/solvers/RK4.jl#L74-L81">source</a></section></article><h2 id="Structures"><a class="docs-heading-anchor" href="#Structures">Structures</a><a id="Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Init" href="#WaterWaves1D.Init"><code>WaterWaves1D.Init</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Init(data ; fast, label)</code></pre><p>Generate an initial data to be used in the function <code>Problem</code>.</p><p><code>data</code> should contain either</p><ul><li>a function <code>η</code> and a function <code>v</code> (in this order);</li><li>a <code>mesh</code> (of type <code>Mesh</code>) and two vectors representing <code>η(mesh.x)</code> and <code>v(mesh.x)</code> (in this order);</li><li>an array of collocation points and two vectors representing <code>η(x)</code> and <code>v(x)</code> (in this order).</li></ul><p>In the last two cases, an optional keyword argument <code>fast</code> can be set to <code>true</code>, (default is <code>false</code>), in which case the algorithm is faster and uses less allocations, but is less precise.</p><p>In the last case, the collocation points must be regularly spaced, otherwise an <code>ErrorException</code> is raised.</p><p>If the keyword <code>label::String</code> (used to display information to the output stream) is not provided, then it is set to the <code>&quot;user-defined&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/init.jl#L21-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.InitialData" href="#WaterWaves1D.InitialData"><code>WaterWaves1D.InitialData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type defining initial data from which initial-value problems can be built, through <code>Problem( model :: AbstractModel, initial :: InitialData, param :: NamedTuple )</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/init.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Mesh" href="#WaterWaves1D.Mesh"><code>WaterWaves1D.Mesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Mesh(args)</code></pre><p>Construct a periodic mesh of <code>N</code> collocation points regularly spaced between <code>xmin</code> (included) and <code>xmax</code> (excluded), and associated Fourier modes.</p><p><strong>Arguments</strong></p><p>Can be either</p><ul><li>a <code>NamedTuple</code> containing <code>N</code> and <code>xmin</code> and <code>xmax</code>; or</li><li>a <code>NamedTuple</code> containing <code>N</code> and <code>L</code> (in which case <code>xmin=-L</code> and <code>xmax=L</code>); or</li><li>a vector of regularly spaced collocation points.</li></ul><p><strong>Return values</strong></p><p><code>m=Mesh(args)</code> is of parametric type and offers with</p><ul><li><code>m.N</code>: number of collocation points and Fourier modes;</li><li><code>m.xmin</code>: minimum of the mesh (included in the vector of collocation points);</li><li><code>m.xmax</code>: maximum of the mesh (excluded in the vector of collocation points);</li><li><code>m.dx</code>: distance between two collocation points;</li><li><code>m.x</code>: the vector of collocation points;</li><li><code>m.k</code>: the vector of wavenumbers;</li><li><code>m.kmin</code>: minimum of wavenumbers (included in the vector of wavenumbers);</li><li><code>m.kmax</code>: maximum of wavenumbers (included in the vector of wavenumbers);</li><li><code>m.dk</code>: distance between two Fourier modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/mesh.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Problem" href="#WaterWaves1D.Problem"><code>WaterWaves1D.Problem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Problem( model, initial, param ; solver, label)</code></pre><p>Build an initial-value problem which can then be solved (i.e. integrated in time) through <code>solve!( problem )</code></p><p><strong>Arguments</strong></p><ul><li><code>model   :: AbstractModel</code>,  the system of equation solved.</li></ul><p>May be built, e.g., by <code>WaterWaves(param)</code>;</p><ul><li><code>initial :: InitialData</code>, the initial data.</li></ul><p>May be buit, e.g., by <code>Init(η,v)</code> where <code>η</code> is the surface deformation and <code>v</code> the derivative of the trace of the velocity potential at the surface;</p><ul><li><code>times :: Times</code> is the time grid, and may be built using the function <code>Times</code>. </li></ul><p>Alternatively one can simply provide a <code>NamedTuple</code> with     - <code>T</code>, the final time of integration     - <code>dt</code>, the timestep     - optionally, <code>Ns</code> the number of computed data or <code>ns</code> for storing data every <code>ns</code> computation steps (by default, every computed data is stored).</p><p><strong>Optional keyword arguments</strong></p><ul><li><code>solver :: TimeSolver</code>, the solver for time integration (default is explicit Runge-Kutta fourth order solver).</li></ul><p>May be built, e.g., by <code>RK4(model)</code> or <code>RK4_naive()</code>.</p><ul><li><code>label   :: String</code> is used in future references (e.g. <code>plot_solution</code>).</li><li>Information are not printed if <code>verbose = false</code> (default is <code>true</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/problem.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.solve!-Tuple{Any}" href="#WaterWaves1D.solve!-Tuple{Any}"><code>WaterWaves1D.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!( problems; verbose=true )</code></pre><p>Solve (i.e. integrate in time) a collection of initial-value problems.</p><p>The argument <code>problems</code> should be a collection (list, array...) of elements of type <code>Problem</code>.</p><p>Information are not printed if keyword argument <code>verbose = false</code> (default is <code>true</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/problem.jl#L167-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.solve!-Tuple{Problem}" href="#WaterWaves1D.solve!-Tuple{Problem}"><code>WaterWaves1D.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!( problem :: Problem; verbose=true )</code></pre><p>Solve (i.e. integrate in time) an initial-value problem</p><p>The argument <code>problem</code> should be of type <code>Problem</code>. It may be buit, e.g., by <code>Problem(model, initial, param)</code></p><p>Information are not printed if keyword argument <code>verbose = false</code> (default is <code>true</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/problem.jl#L100-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Data" href="#WaterWaves1D.Data"><code>WaterWaves1D.Data</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Data( m :: Matrix )</code></pre><p>Data structure to store the solution of an initial-value problem along time.</p><p><code>data=Data(m)</code> is of parametric type and offers</p><ul><li><code>data.U</code>, a 1-element vector with a copy of the matrix <code>m</code>;</li><li><code>(data.datalength,data.datasize)=size(m)</code>  where <code>datalength</code> is the number of computed modes, and <code>datasize</code> the number of involved equations, typically 2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/data.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Times" href="#WaterWaves1D.Times"><code>WaterWaves1D.Times</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Times(param; ns, Ns)</code></pre><p>Constructs a mesh of times, to be used in initial-value problems (see <code>Problem</code>).</p><p><strong>Arguments</strong></p><p><code>param</code> is either</p><ul><li>a <code>NamedTuple</code> containing <code>dt</code> the timestep and <code>T</code> the final time of comuptation; or</li><li>a vector of computed times.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>ns</code>  : data are stored every <code>ns</code> computations (optional, default = 1).</li><li><code>Ns</code>  : <code>Ns</code> data (in addition to the initial datum) are stored (optional, by default `floor( tfin/dt)).</li></ul><p>If both <code>Ns</code> and <code>ns</code> are given, <code>Ns</code> overrules <code>ns</code>.</p><p><strong>Return values</strong></p><p><code>t=Times(args)</code> is of parametric type and offers</p><ul><li><code>t.Nc</code>: number of computed times (including initial datum);</li><li><code>t.Ns</code>: number of stored times (including initial datum);</li><li><code>t.ns</code>: number of computed times between two stored times;</li><li><code>t.tfin</code>: the final time;</li><li><code>t.dt</code>: the timestep;</li><li><code>t.tc</code> : the vector of computed times;</li><li><code>t.ts</code>: the vector of stored times.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/times.jl#L2-L27">source</a></section></article><h2 id="Tools"><a class="docs-heading-anchor" href="#Tools">Tools</a><a id="Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.energy-Tuple{Problem}" href="#WaterWaves1D.energy-Tuple{Problem}"><code>WaterWaves1D.energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy(pb::Problem;T)</code></pre><p>Compute the excess of mass of a solved initial-value problem <code>pb</code> at a given time <code>T</code>.</p><p>Keyword argument <code>T</code> is optional, the last computed time is used by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/tools.jl#L157-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.energydiff-Tuple{Problem}" href="#WaterWaves1D.energydiff-Tuple{Problem}"><code>WaterWaves1D.energydiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energydiff(pb::Problem;T,rel)</code></pre><p>Compute the difference of energy of a solved initial-value problem <code>pb</code> between given time <code>T</code> and initial time.</p><p>Keyword argument <code>T</code> is optional, the last computed time is used by default.</p><p>If keyword argument <code>rel=true</code> (default is false), then compute the relative difference (with initial value as reference).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/tools.jl#L218-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.interpolate-Tuple{Mesh, Any, Any}" href="#WaterWaves1D.interpolate-Tuple{Mesh, Any, Any}"><code>WaterWaves1D.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(mesh,vector,x;fast)</code></pre><p>Interpolate a vector <code>vector</code> of values on a uniform collocation grid defined by <code>mesh</code>, on collocation points given by <code>x</code>.</p><p>If the collocation points <code>x</code> are regularly spaced and the optional keyword argument <code>fast</code> is set to <code>true</code> (default is <code>false</code>), then the algorithm is faster and uses less allocations, but is less precise.</p><p>Return the vector of values on collocation points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/tools.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.interpolate-Tuple{Mesh, Any}" href="#WaterWaves1D.interpolate-Tuple{Mesh, Any}"><code>WaterWaves1D.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(mesh,vector;n=2^3)</code></pre><p>Interpolate a vector <code>vector</code> of values on a uniform collocation grid defined by <code>mesh</code>.</p><p>Return <code>(new_mesh,new_vector)</code> a new uniform mesh with <code>n</code> times as many values, and the vector of values at these collocation points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/tools.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.mass-Tuple{Problem}" href="#WaterWaves1D.mass-Tuple{Problem}"><code>WaterWaves1D.mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mass(pb::Problem;T)</code></pre><p>Compute the excess of mass of a solved initial-value problem <code>pb</code> at a given time <code>T</code>.</p><p>Keyword argument <code>T</code> is optional, the last computed time is used by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/tools.jl#L123-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.massdiff-Tuple{Problem}" href="#WaterWaves1D.massdiff-Tuple{Problem}"><code>WaterWaves1D.massdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">massdiff(pb::Problem;T,rel)</code></pre><p>Compute the difference of excess of mass of a solved initial-value problem <code>pb</code> between given time <code>T</code> and initial time.</p><p>Keyword argument <code>T</code> is optional, the last computed time is used by default.</p><p>If keyword argument <code>rel=true</code> (default is false), then compute the relative difference (with initial value as reference).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/tools.jl#L178-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.momentum-Tuple{Problem}" href="#WaterWaves1D.momentum-Tuple{Problem}"><code>WaterWaves1D.momentum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">momentum(pb::Problem;T)</code></pre><p>Compute the horizontal impulse of a solved initial-value problem <code>pb</code> at a given time <code>T</code>.</p><p>Keyword argument <code>T</code> is optional, the last computed time is used by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/tools.jl#L140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.momentumdiff-Tuple{Problem}" href="#WaterWaves1D.momentumdiff-Tuple{Problem}"><code>WaterWaves1D.momentumdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">momentumdiff(pb::Problem;T,rel)</code></pre><p>Compute the difference of horizontal impulse of a solved initial-value problem <code>pb</code> between given time <code>T</code> and initial time.</p><p>Keyword argument <code>T</code> is optional, the last computed time is used by default.</p><p>If keyword argument <code>rel=true</code> (default is false), then compute the relative difference (with initial value as reference).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/tools.jl#L198-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.solution-Tuple{Problem}" href="#WaterWaves1D.solution-Tuple{Problem}"><code>WaterWaves1D.solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solution(pb::Problem;T,x,interpolation)</code></pre><p>Give the solution of a solved initial-value problem at a given time <code>T</code>.</p><p><strong>Arguments</strong></p><ul><li>Argument <code>pb</code> is of type <code>Problem</code>.</li><li>Keyword argument <code>T</code> is optional, the last computed time is returned by default.</li><li>Keyword argument <code>x</code> is optional, if provided the solution is interpolated to the collocation vector <code>x</code>.</li><li>Keyword argument <code>interpolation</code> is optional, if an integer is provided the solution is interpolated on as many collocation points (if <code>true</code>, then the default value <code>2^3</code> is chosen).</li></ul><p><strong>Return values</strong></p><p>Return <code>(η,v,x,t)</code> where</p><ul><li><code>η</code> is the surface deformation at collocation points;</li><li><code>v</code> is the tangential velocity (derivative of the trace of the velocity potential) at collocation points;</li><li><code>x</code> is the vector of collocation points;</li><li><code>t</code> the time (first computed time greater or equal to provided <code>T</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/tools.jl#L69-L88">source</a></section></article><h2 id="Load-and-save"><a class="docs-heading-anchor" href="#Load-and-save">Load and save</a><a id="Load-and-save-1"></a><a class="docs-heading-anchor-permalink" href="#Load-and-save" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.dump-Tuple{String, Data}" href="#Base.dump-Tuple{String, Data}"><code>Base.dump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dump(file_name :: String, data :: Data)</code></pre><p>Save <code>data</code> to the file with name <code>file_name</code> (and extension &quot;.h5&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/loadsave.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.dump-Tuple{String, Problem}" href="#Base.dump-Tuple{String, Problem}"><code>Base.dump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dump(file_name  :: String, problem :: Problem)</code></pre><p>Save the data of <code>problem</code> to the file with name <code>file_name</code> (and extension &quot;.h5&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/loadsave.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.dump-Tuple{String, Vector, InitialData}" href="#Base.dump-Tuple{String, Vector, InitialData}"><code>Base.dump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dump(file_name :: String, x::Vector, init::InitialData )</code></pre><p>Save the values of the initial data <code>init</code> at collocation points <code>x</code> to the file with name <code>file_name</code> (and extension &quot;.h5&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/loadsave.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.load_data!-Tuple{String, Problem}" href="#WaterWaves1D.load_data!-Tuple{String, Problem}"><code>WaterWaves1D.load_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_data!(file_name :: String, problem :: Problem)</code></pre><p>Fills <code>problem</code> with raw data extracted from the file with name <code>file_name</code> (and extension &quot;.h5&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/loadsave.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.load_data-Tuple{String}" href="#WaterWaves1D.load_data-Tuple{String}"><code>WaterWaves1D.load_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_data(file_name :: String)</code></pre><p>Load data from the file with name <code>file_name</code> (and extension &quot;.h5&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/loadsave.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.load_init-Tuple{String}" href="#WaterWaves1D.load_init-Tuple{String}"><code>WaterWaves1D.load_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_init(file_name :: String; fast = false)</code></pre><p>Load initial data from  the file with name <code>file_name</code> (and extension &quot;.h5&quot;).</p><p>Keyword argument <code>fast</code> is optional (default is <code>false</code>), and corresponds the the keyword argument of the function <code>Init</code>.</p><p>Return an object of type <code>InitialData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/fd46a22887b704a33b5a20af4cc8c56f331ba2f7/src/loadsave.jl#L90-L99">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plot_recipes/">« Plot recipes</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Friday 20 May 2022 07:01">Friday 20 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
