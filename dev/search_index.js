var documenterSearchIndex = {"docs":
[{"location":"library/#Library-(index)","page":"Library","title":"Library (index)","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#Initial-data","page":"Library","title":"Initial data","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [ \"library/#initial-data.md\" ]","category":"page"},{"location":"library/#WaterWaves1D.CnoidalSGN","page":"Library","title":"WaterWaves1D.CnoidalSGN","text":"CnoidalSGN(param; P=1)\n\nBuild the initial data associated with CnoidalWaveSerreGreenNaghdi(param; P=1), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.CnoidalWaveSerreGreenNaghdi-Tuple{NamedTuple}","page":"Library","title":"WaterWaves1D.CnoidalWaveSerreGreenNaghdi","text":"CnoidalWaveSerreGreenNaghdi(param; P=1)\n\nCompute the Serre-Green-Naghdi cnoidal wave with prescribed h₀<h₁<h₂. h₁ is the minimum, h₂ is the maximum of the wave. As h₀ -> h₁, the cnoidal wave converges towards the solitary wave. See for instance Gavrilyuk, Nkonga, Shyue and Truskinovsky.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing h₀<h₁<h₂ and dimensionless parameters ϵ and μ, and number of collocation points N.\nP :: Int: (keyword, optional, default = 1) the number of periods of the cnoidal wave in the constructed mesh.\n\nReturn values\n\n(η,u,v,mesh,param) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: derivative of the trace of the velocity potential at the surface;\nmesh :: Mesh: mesh collocation points;\nparam :: NamedTuple: useful parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.SolitarySGN","page":"Library","title":"WaterWaves1D.SolitarySGN","text":"SolitarySGN(param; x₀=0)\n\nBuild the initial data associated with SolitaryWaveSerreGreenNaghdi(param; x₀=0), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitarySGN(c; ϵ=1,μ=1,x₀=0,N=2^12)\n\nBuild the initial data with velocity c, center x₀, dimensionless parameters ϵ and μ, and number of collocation points N.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SolitaryWaveSerreGreenNaghdi-Tuple{NamedTuple}","page":"Library","title":"WaterWaves1D.SolitaryWaveSerreGreenNaghdi","text":"SolitaryWaveSerreGreenNaghdi(param; x₀=0)\n\nCompute the Serre-Green-Naghdi solitary wave with prescribed velocity.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\nx₀ :: Real: (keyword, optional, default = 0) center of solitary wave.\n\nReturn values\n\n(η,u,v,mesh) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: derivative of the trace of the velocity potential at the surface;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.SolitaryWGN","page":"Library","title":"WaterWaves1D.SolitaryWGN","text":"SolitaryWGN(param; kwargs)\n\nBuild the initial data associated with SolitaryWaveWhithamGreenNaghdi(param; kwargs), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitaryWGN(c; ϵ=1,μ=1,N=2^12,kwargs)\n\nBuild the initial data with velocity c, dimensionless parameters ϵ and μ, and number of collocation points N, and kwargs the other (optional) keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple}","page":"Library","title":"WaterWaves1D.SolitaryWaveWhithamGreenNaghdi","text":"SolitaryWaveWhithamGreenNaghdi(param; kwargs)\n\nCompute the Whitham-Green-Naghdi solitary wave with prescribed velocity.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\nSGN :: Bool: if true computes the Serre-Green-Naghdi (instead of Whitham-Green-Naghdi) solitary wave (consider SolitaryWaveSerreGreenNaghdi instead);\nmethod :: Int: equation used (between 1 and 4);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false (default is false);\nverbose :: Bool: prints numerical errors at each step if true (default is false);\nmax_iter :: Int: maximum number of iterations of the Newton algorithm (default is 20);\ntol :: Real: relative tolerance measured in ℓ∞ norm (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with u_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian (default is 0).\n\nReturn values\n\n(η,u,v,mesh) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: derivative of the velocity potential at the surface;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.SolitaryWB","page":"Library","title":"WaterWaves1D.SolitaryWB","text":"SolitaryWB(param; kwargs)\n\nBuild the initial data associated with SolitaryWaveWhithamBoussinesq(param; kwargs), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitaryWB(c; ϵ=1,μ=1,N=2^12,kwargs)\n\nBuild the initial data with velocity c, dimensionless parameters ϵ and μ, and number of collocation points N, and kwargs the other (optional) keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SolitaryWaveWhithamBoussinesq-Tuple{NamedTuple}","page":"Library","title":"WaterWaves1D.SolitaryWaveWhithamBoussinesq","text":"SolitaryWaveWhithamBoussinesq(param; kwargs)\n\nCompute the Whitham-Boussinesq solitary wave with prescribed velocity.\n\nArgument\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ,\n\nand mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\nα :: Real: determines the model used (typically 1 or 1/2, default is 1);\nBoussinesq: if true (default is false), compute the standard Boussinesq system with parameters a (defaut -1//3), b=d (defaut 1//3), and c=0);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*(u_n+du)+(1-q)*u_n (default is 1);\n\nβ :: Real: adds β times spectral projection onto the Kernel to the Jacobian.β\n\nReturn values\n\n(η,v,mesh) with\n\nη :: Vector{Float64}: surface deformation;\nv :: Vector{Float64}: velocity (derivative of the trace of the velocity potential at the surface);\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.SolitaryWhitham","page":"Library","title":"WaterWaves1D.SolitaryWhitham","text":"SolitaryWhitham(param; kwargs)\n\nBuild the initial data associated with SolitaryWaveWhitham(param; kwargs), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitaryWhitham(c; ϵ=1,μ=1,N=2^12,kwargs)\n\nBuild the initial data with velocity c, dimensionless parameters ϵ and μ, and number of collocation points N, and kwargs the other (optional) keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SolitaryWaveWhitham-Tuple{NamedTuple}","page":"Library","title":"WaterWaves1D.SolitaryWaveWhitham","text":"SolitaryWaveWhitham(param; kwargs)\n\nCompute the Whitham solitary wave with prescribed velocity.\n\nArgument\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for KdV is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\n\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian;\nKdV :: Bool: if true computes the KdV (instead of Whitham) solitary wave.\n\nReturn values\n\n(u,mesh) with\n\nu :: Vector{Float64}: the solution;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.Random","page":"Library","title":"WaterWaves1D.Random","text":"Random(param;args)\n\nRandomly generated initial data, based on provided (optional arguments) :\n\nL is the typical wavelength (default is L=1),\ns is the (real) Sobolev index regularity (default is s=∞),\nλ is the length of spatial localization (default is λ=∞, no localization),\na is the couple of amplitudes of the surface deformation, and velocity (default is a=(1,1)).\n\nReturn an initial data init::InitialData,  to be used in initial-value problems Problem(model, init, param), with init.η and init.v two samples of random(x;L,s,λ), where x is the set of collocation points generated by Mesh(param).\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.random-Tuple{Any}","page":"Library","title":"WaterWaves1D.random","text":"random(x;args)\n\nRandomly generate a vector of values at collocation points x, based on provided (optional arguments) :\n\nL is the typical wavelength (default is L=1),\ns is the (real) Sobolev index regularity (default is s=∞, smooth data),\nλ is the length of spatial localization (default is λ=∞, no localization),\na is the amplitude of the returned vector (default is a=1).\n\nThe vector is generated through randomly chosen Fourier coefficients, multiplied with weigth w=10^(-|k|L/(2π)) if s=∞, or w=1/(1+9(|k|L/(2π))^(s+1/2)) otherwise. If λ≠∞, the function in spatial variables is multiplied by exp(-|x/λ|^2), and in any case normalized to have maximum absolute value 1.\n\n\n\n\n\n","category":"method"},{"location":"library/#Models","page":"Library","title":"Models","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [ \"/#models\" ]","category":"page"},{"location":"library/#WaterWaves1D.AbstractModel","page":"Library","title":"WaterWaves1D.AbstractModel","text":"Abstract type whose subtypes are the models from which initial-value problems can be built, through Problem( model :: AbstractModel, initial :: InitialData, param :: NamedTuple )\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Airy","page":"Library","title":"WaterWaves1D.Airy","text":"Airy(param;mesh,label)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the linear (Airy) water waves equations.\n\nArguments\n\nparam::NamedTuple must contain\nthe shallowness parameter μ (set the infinite-layer case if μ=Inf);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise;\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided.\nmesh  :: Mesh: the mesh of collocation points. By default, mesh = Mesh(param).\nlabel :: String: a label for future references (default is \"linear (Airy)\").\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function Airy.f! to be called in explicit time-integration solvers;\na function Airy.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function Airy.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.AkersNicholls","page":"Library","title":"WaterWaves1D.AkersNicholls","text":"AkersNicholls(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the quadratic deep-water model proposed by Akers and Nicholls and Cheng, Granero-Belinchón, Shkoller and Milewski\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\ndealias: dealiasing with 1/3 Orszag rule if true or no dealiasing if false (by default);\nlabel: a label for future references (default is \"deep quadratic\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function AkersNicholls.f! to be called in explicit time-integration solvers;\na function AkersNicholls.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function AkersNicholls.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.AkersNicholls_fast","page":"Library","title":"WaterWaves1D.AkersNicholls_fast","text":"AkersNicholls_fast(param;kwargs)\n\nSame as AkersNicholls, but faster.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Boussinesq","page":"Library","title":"WaterWaves1D.Boussinesq","text":"Boussinesq(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for abcd-Boussinesq models (with b=d and c=0). See Bona, Chen, and Saut\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\ntwo parameters a (default is -1/3) and b (default is +1/3) which determine the model solved. You need a+2*b=1/3 for validity as a long wave model (without surface tension).\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Boussinesq\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function Boussinesq.f! to be called in explicit time-integration solvers;\na function Boussinesq.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function Boussinesq.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Choi","page":"Library","title":"WaterWaves1D.Choi","text":"Choi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the model proposed by Choi.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nM∈{0,1,2}: the order of the model. M=2 by default;\nreg: applies a regularization operator. reg=false by default.\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Choi-N\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function Choi.f! to be called in explicit time-integration solvers;\na function Choi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function Choi.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\n\n- `η` is the values of surface deformation at collocation points `x`;\n- `v` is the derivative of the trace of the velocity potential;\n\nadditionally, a handy function Choi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u,vᵦ), where\n\n- `v` is the derivative of the trace of the velocity potential;\n- `u` corresponds to the layer-averaged horizontal velocity;\n- `vᵦ` corresponds to the horizontal velocity at the bottom.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.IsobeKakinuma","page":"Library","title":"WaterWaves1D.IsobeKakinuma","text":"IsobeKakinuma(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the Isobe-Kakinuma model proposed by Isobe.\n\nArgument\n\nparam is of type NamedTuple (or a collection NamedTuples) of and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Isobe-Kakinuma\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function IsobeKakinuma.f! to be called in explicit time-integration solvers;\na function IsobeKakinuma.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function IsobeKakinuma.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Matsuno","page":"Library","title":"WaterWaves1D.Matsuno","text":"Matsuno(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the quadratic deep-water model proposed by Matsuno.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\ndealias: dealiasing with 1/3 Orszag rule if true or no dealiasing if false (by default);\nlabel: a label for future references (default is \"Matsuno\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function Matsuno.f! to be called in explicit time-integration solvers;\na function Matsuno.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function Matsuno.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Matsuno_fast","page":"Library","title":"WaterWaves1D.Matsuno_fast","text":"Matsuno_fast(param;kwargs)\n\nSame as Matsuno, but faster.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.NonHydrostatic","page":"Library","title":"WaterWaves1D.NonHydrostatic","text":"NonHydrostatic(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the \"Non-hydrostatic\" model proposed by Bristeau, Mangeney, Sainte-Marie and Seguin\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"non-hydrostatic\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function NonHydrostatic.f! to be called in explicit time-integration solvers;\na function NonHydrostatic.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function NonHydrostatic.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x;\nadditionally, a handy function NonHydrostatic.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SaintVenant","page":"Library","title":"WaterWaves1D.SaintVenant","text":"SaintVenant(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for Saint-Venant (or shallow water) model.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\nthe dimensionless parameter ϵ (nonlinearity);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: no dealisasing if set to 0 or false (default), otherwise 1/(3*dealias) modes are set to 0 (corresponding to standard 2/3 Orszag rule if dealias is set to 1 or true);\nsmooth: A smooth low-pass filter (whose scaling is defined by ) if set to 0 or false (default), otherwise only 2/(3*dealias)*(1-smooth/2) modes are kept untouched;\nlabel: a label for future references (default is \"Saint-Venant\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SaintVenant.f! to be called in explicit time-integration solvers;\na function SaintVenant.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SaintVenant.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the layer-averaged velocity (or the derivative of the trace of the velocity potential) at x.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SaintVenant2D","page":"Library","title":"WaterWaves1D.SaintVenant2D","text":"SaintVenant2D(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for Saint-Venant (or shallow water) model.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\nthe dimensionless parameter ϵ (nonlinearity);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: no dealisasing if set to 0 or false (default), otherwise 1/(3*dealias) modes are set to 0 (corresponding to standard 2/3 Orszag rule if dealias is set to 1 or true);\nsmooth: A smooth low-pass filter (whose scaling is defined by ) if set to 0 or false (default), otherwise only 2/(3*dealias)*(1-smooth/2) modes are kept untouched;\nlabel: a label for future references (default is \"Saint-Venant\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SaintVenant2D.f! to be called in explicit time-integration solvers;\na function SaintVenant2D.mapto which from (η,vx,vy) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SaintVenant2D.mapfro which from such data matrix returns the Tuple of real vectors (η,vx,vy,x,y), where\nη is the values of surface deformation at collocation points (x,y);\nvx,vy are the velocity fields at collocation points (x,y).\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SaintVenant2D_fast","page":"Library","title":"WaterWaves1D.SaintVenant2D_fast","text":"SaintVenant_fast(param;kwargs)\n\nSame as SaintVenant, but faster.\n\nIf the optional argument large_data is set to true (default is false), then the standard fft,ifft functions are used. This may be faster, while using more allocations.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SaintVenant_fast","page":"Library","title":"WaterWaves1D.SaintVenant_fast","text":"SaintVenant_fast(param;kwargs)\n\nSame as SaintVenant, but faster.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SerreGreenNaghdi","page":"Library","title":"WaterWaves1D.SerreGreenNaghdi","text":"SerreGreenNaghdi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the Serre-Green-Naghdi model (Serre, Su and Gardner, Green and Naghdi).\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Green-Naghdi\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SerreGreenNaghdi.f! to be called in explicit time-integration solvers;\na function SerreGreenNaghdi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SerreGreenNaghdi.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x;\nadditionally, a handy function SerreGreenNaghdi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.SquareRootDepth","page":"Library","title":"WaterWaves1D.SquareRootDepth","text":"SquareRootDepth(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the \"√D\" model proposed by Cotter, Holm and Percival\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"square-root depth\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SquareRootDepth.f! to be called in explicit time-integration solvers;\na function SquareRootDepth.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SquareRootDepth.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x;\nadditionally, a handy function SquareRootDepth.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.WWn","page":"Library","title":"WaterWaves1D.WWn","text":"WWn(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the water waves expansion proposed by Dommermuth and Yue, West et al., Craig and Sulem (see also the account by Choi) with the \"rectification\" method proposed by Duchêne and Melinand.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nn :: Int: the order of the expansion; linear system if 1, quadratic if 2, cubic if 3, quartic if 4 (default and other values yield 2);\nδ and m: parameters of the rectifier operator, set as k->min(1,|δ*k|^m) or k->min(1,|δ*k|^m[1]*exp(1-|δ*k|^m[2])) if m is a couple\n\n(by default is δ=0, i.e. no regularization and m=-1. Notice m=-Inf and δ>0 yields a cut-off filter);\n\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"WWn\" with n the order of the expansion);\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WWn.f! to be called in explicit time-integration solvers (also WWn.f1! and WWn.f2! for the symplectic Euler solver);\na function WWn.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WWn.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\n\n- `η` is the values of surface deformation at collocation points `x`;\n- `v` is the derivative of the trace of the velocity potential at `x`.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.WaterWaves","page":"Library","title":"WaterWaves1D.WaterWaves","text":"WaterWaves(param; kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the water waves system (via conformal mapping, see Zakharov, Dyachenko and Vasilyev).\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nIL: Set the infinite-layer case if IL=true, in which case ϵ is the steepness parameter. Default is false.\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nmethod ∈ {1,2,3}: method used to initialize the conformal mapping, as a fix-point problem F(u)=u\nif method == 1, use standard contraction fix-point iteration;\nif method == 2, use Newton algorithm with GMRES iterative solver to invert the Jacobian;\nif method == 3, use Newton algorithm with direct solver to invert the Jacobian;\ntol: (relative) tolerance of the fix-point algorithm (default is 1e-16);\nmaxiter: the maximal number of iteration in the fix-point algorithm (default is 100);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"water waves\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WaterWaves.f! to be called in the explicit time-integration solver (also WaterWaves.f1! and WaterWaves.f2! for the symplectic Euler solver);\na function WaterWaves.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WaterWaves.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nx is a vector of collocation points (non-regularly spaced);\n\n- `η` is the values of surface deformation at collocation points `x`;\n- `v` is the derivative of the trace of the velocity potential at `x`.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Whitham","page":"Library","title":"WaterWaves1D.Whitham","text":"Whitham(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for two uncoupled Whitham equations, following Emerald.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nKdV: if true (default is false), compute the standard KdV equations instead (see KdV(param;kwargs));\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Whitham-Boussinesq\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function Whitham.f! to be called in explicit time-integration solvers;\na function Whitham.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed.\na function Whitham.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\n\n- `η` is the values of surface deformation at collocation points `x`;\n- `v` is the derivative of the trace of the velocity potential at `x`.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.WhithamBoussinesq","page":"Library","title":"WaterWaves1D.WhithamBoussinesq","text":"WhithamBoussinesq(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for a Boussinesq-type model with full-dispersion property.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nBoussinesq: if true (default is false), compute the standard Boussinesq system instead (see Boussinesq(param;kwargs));\na parameter α which determines the model solved:\nIf α = 1 (default), then the model has been introduced in Dinvay, Dutykh and Kalisch;\nIf α = 1/2, then the model is a quasilinear version;\nIf α < 1/2, then expect instabilities stemming from ill-posedness of the model.\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Whitham-Boussinesq\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WhithamBoussinesq.f! to be called in explicit time-integration solvers;\na function WhithamBoussinesq.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed.\na function WhithamBoussinesq.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\n\n- `η` is the values of surface deformation at collocation points `x`;\n- `v` is the derivative of the trace of the velocity potential at `x`.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.WhithamGreenNaghdi","page":"Library","title":"WaterWaves1D.WhithamGreenNaghdi","text":"WhithamGreenNaghdi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the fully dispersive Green-Naghdi model proposed by Duchêne, Israwi and Talhouk.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nSGN: if true (default is false), compute the Serre-Green-Naghdi (SGN) instead of Whitham-Green-Naghdi (WGN) system (see SerreGreenNaghdi(param;kwargs));\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Whitham-Green-Naghdi\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WhithamGreenNaghdi.f! to be called in explicit time-integration solvers;\na function WhithamGreenNaghdi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WhithamGreenNaghdi.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\n\n- `η` is the values of surface deformation at collocation points `x`;\n- `v` is the derivative of the trace of the velocity potential at `x`;\n\nadditionally, a handy function WhithamGreenNaghdi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.bilayerSaintVenant","page":"Library","title":"WaterWaves1D.bilayerSaintVenant","text":"bilayerSaintVenant(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the bilayer Saint-Venant (or shallow water) model.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\nthe dimensionless parameter ϵ (nonlinearity);\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: no dealisasing if set to 0 or false (default), standard 3/2 Orszag rule if set to 1 or true, otherwise the value sets additionnally a maximal slope of the dealiasing symbol (2/dealias models are affected);\nlabel: a label for future references (default is \"Saint-Venant\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function bilayerSaintVenant.f! to be called in explicit time-integration solvers;\na function bilayerSaintVenant.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function bilayerSaintVenant.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.modifiedMatsuno","page":"Library","title":"WaterWaves1D.modifiedMatsuno","text":"modifiedMatsuno(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the modified Matsuno model proposed by Duchêne and Melinand.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"modified Matsuno\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function modifiedMatsuno.f! to be called in explicit time-integration solvers;\na function modifiedMatsuno.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function modifiedMatsuno.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.relaxedGreenNaghdi","page":"Library","title":"WaterWaves1D.relaxedGreenNaghdi","text":"relaxedGreenNaghdi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for a relaxed Green-Naghdi model proposed by N. Favrie and S. Gavrilyuk  or C. Escalante, M. Dumbser and M. Castro  and G. Richard.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nthe relaxation parameter a;\nnumerical parameters to construct the mesh of collocation points, if mesh is not provided as a keyword argument.\n\nOptional keyword arguments\n\nFG: if true (default is false), compute the Favrie-Gavrilyuk model, otherwise compute the Escalante-Dumbser-Castro model;\nid: ∈{0,1,2} and represent the level of preparation of the initial data (default is 1);\nmesh: the mesh of collocation points. By default, mesh = Mesh(param);\niterative: solve the elliptic problem (to construct initial data) through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orszag rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Favrie-Gavrilyuk\" if FG==true, \"Escalante-Dumbser-Castro\" otherwise);\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function relaxedGreenNaghdi.f! to be called in explicit time-integration solvers;\na function relaxedGreenNaghdi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function relaxedGreenNaghdi.mapfro which from such data matrix returns the Tuple of real vectors (η,v,x), where\n\n- `η` is the values of surface deformation at collocation points `x`;\n- `v` is the derivative of the trace of the velocity potential at `x`;\n\nadditionally, a handy function relaxedGreenNaghdi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u,p,w), where\n\n- `u` corresponds to the layer-averaged horizontal velocity.\n- `p` corresponds to the relaxed (artificial) layer-averaged non-hydrostatic pressure;\n- `w` corresponds to the relaxed (artificial) layer-averaged vertical velocity.\n\n\n\n\n\n","category":"type"},{"location":"library/#Solvers","page":"Library","title":"Solvers","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [ \"library#solvers.md\" ]","category":"page"},{"location":"library/#WaterWaves1D.Euler","page":"Library","title":"WaterWaves1D.Euler","text":"Euler(arguments;realdata)\n\nExplicit Euler solver.\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,datasize) where N is the number of collocation points and datasize the number of equations solved;\n(param,datasize) where param is aNamedTuplecontaining a keyN, anddatasizea integer (optional, by defaultdatasize=2`).\n\nThe keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case 0. and 1., complex-valued in case 2..\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.EulerSymp","page":"Library","title":"WaterWaves1D.EulerSymp","text":"EulerSymp(arguments;Niter,implicit,realdata)\n\nSymplectic Euler solver. The implicit Euler method is first used on one equation, then the explicit Euler method is used on the second one. The implicit equation is solved via Neumann iteration\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,2) where N is the number of collocation points;\na NamedTuple containing a key N.\n\nThe keyword argument Niter (optional, defaut value = 10) determines the number of steps in the Neumann iteration solver of the implicit step. The keyword argument implicit (optional, defaut value = 1) determines which equation is implicit (must be 1 or 2). The keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case 0. and 1., complex-valued in case 2..\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Euler_naive","page":"Library","title":"WaterWaves1D.Euler_naive","text":"Euler_naive()\n\nRunge-Kutta fourth order solver.\n\nA naive version of Euler, without argument since no pre-allocation is performed.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.RK4","page":"Library","title":"WaterWaves1D.RK4","text":"RK4(arguments;realdata)\n\nExplicit Runge-Kutta fourth order solver.\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel, typically the model you will solve with the solver;\nan Array which has the size of the objects that the solver will manipulate (typically a vector of systemsize elements of size N where N is the number of collocation points and systemsize the number of solved equations);\na (datasize,systemsize) where datasize is the size of scalar variables (typically N the number of collocation points) and datasize (optional, by default systemsize=2) the number of solved equations);\n(param,systemsize) where param is a NamedTuple containing a key N describing the number of collocation points, and systemsize the number of solved equations (optional, by default systemsize=2).\n\nThe keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case 0. and 1., complex-valued in case 2..\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.RK4_naive","page":"Library","title":"WaterWaves1D.RK4_naive","text":"RK4_naive()\n\nRunge-Kutta fourth order solver.\n\nA naive version of RK4, without argument since no pre-allocation is performed.\n\n\n\n\n\n","category":"type"},{"location":"library/#Structures","page":"Library","title":"Structures","text":"","category":"section"},{"location":"library/#WaterWaves1D.Init","page":"Library","title":"WaterWaves1D.Init","text":"Init(data ; fast, label)\n\nGenerate an initial data to be used in the function Problem.\n\ndata should contain either\n\na function η and a function v (in this order);\na mesh (of type Mesh) and two vectors representing η(mesh.x) and v(mesh.x) (in this order);\nan array of collocation points and two vectors representing η(x) and v(x) (in this order).\n\nIn the last two cases, an optional keyword argument fast can be set to true, (default is false), in which case the algorithm is faster and uses less allocations, but is less precise.\n\nIn the last case, the collocation points must be regularly spaced, otherwise an ErrorException is raised.\n\nIf the keyword label::String (used to display information to the output stream) is not provided, then it is set to the \"user-defined\".\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Init2D","page":"Library","title":"WaterWaves1D.Init2D","text":"Init2D(data ; fast, label)\n\nGenerate a two-dimensional initial data to be used in the function Problem.\n\ndata should contain either\n\na function η and a function v (in this order);\na mesh (of type Mesh) and two vectors representing η(mesh.x) and v(mesh.x) (in this order);\nan array of collocation points and two vectors representing η(x) and v(x) (in this order).\n\nIn the last two cases, an optional keyword argument fast can be set to true, (default is false), in which case the algorithm is faster and uses less allocations, but is less precise.\n\nIn the last case, the collocation points must be regularly spaced, otherwise an ErrorException is raised.\n\nIf the keyword label::String (used to display information to the output stream) is not provided, then it is set to the \"user-defined\".\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.InitialData","page":"Library","title":"WaterWaves1D.InitialData","text":"Abstract type defining initial data from which initial-value problems can be built, through Problem( model :: AbstractModel, initial :: InitialData, param :: NamedTuple )\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Mesh","page":"Library","title":"WaterWaves1D.Mesh","text":"Mesh(args)\n\nConstruct a periodic mesh of N collocation points regularly spaced between xmin (included) and xmax (excluded), and associated Fourier modes.\n\nArguments\n\nCan be either\n\na NamedTuple containing N and xmin and xmax; or\na NamedTuple containing N and L (in which case xmin=-L and xmax=L); or\na vector of regularly spaced collocation points.\n\nReturn values\n\nm=Mesh(args) is of parametric type and offers with\n\nm.N: number of collocation points and Fourier modes;\nm.xmin: minimum of the mesh (included in the vector of collocation points);\nm.xmax: maximum of the mesh (excluded in the vector of collocation points);\nm.dx: distance between two collocation points;\nm.x: the vector of collocation points;\nm.k: the vector of wavenumbers;\nm.kmin: minimum of wavenumbers (included in the vector of wavenumbers);\nm.kmax: maximum of wavenumbers (included in the vector of wavenumbers);\nm.dk: distance between two Fourier modes.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Problem","page":"Library","title":"WaterWaves1D.Problem","text":"Problem( model, initial, param ; solver, label)\n\nBuild an initial-value problem which can then be solved (i.e. integrated in time) through solve!( problem )\n\nArguments\n\nmodel   :: AbstractModel,  the system of equation solved.\n\nMay be built, e.g., by WaterWaves(param);\n\ninitial :: InitialData, the initial data.\n\nMay be buit, e.g., by Init(η,v) where η is the surface deformation and v the derivative of the trace of the velocity potential at the surface;\n\ntimes :: Times is the time grid, and may be built using the function Times. \n\nAlternatively one can simply provide a NamedTuple with     - T, the final time of integration     - dt, the timestep     - optionally, Ns the number of computed data or ns for storing data every ns computation steps (by default, every computed data is stored).\n\nOptional keyword arguments\n\nsolver :: TimeSolver, the solver for time integration (default is explicit Runge-Kutta fourth order solver).\n\nMay be built, e.g., by RK4(model) or RK4_naive().\n\nlabel   :: String is used in future references (e.g. plot_solution).\nInformation are not printed if verbose = false (default is true).\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.solve!-Tuple{Any}","page":"Library","title":"WaterWaves1D.solve!","text":"solve!( problems; verbose=true )\n\nSolve (i.e. integrate in time) a collection of initial-value problems.\n\nThe argument problems should be a collection (list, array...) of elements of type Problem.\n\nInformation are not printed if keyword argument verbose = false (default is true).\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.solve!-Tuple{Problem}","page":"Library","title":"WaterWaves1D.solve!","text":"solve!( problem :: Problem; verbose=true )\n\nSolve (i.e. integrate in time) an initial-value problem\n\nThe argument problem should be of type Problem. It may be buit, e.g., by Problem(model, initial, param)\n\nInformation are not printed if keyword argument verbose = false (default is true).\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.Data","page":"Library","title":"WaterWaves1D.Data","text":"Data( m :: Matrix )\n\nData structure to store the solution of an initial-value problem along time.\n\ndata=Data(m) is of parametric type and offers\n\ndata.U, a 1-element vector with a copy of the matrix m;\n(data.datalength,data.datasize)=size(m)  where datalength is the number of computed modes, and datasize the number of involved equations, typically 2.\n\n\n\n\n\n","category":"type"},{"location":"library/#WaterWaves1D.Times","page":"Library","title":"WaterWaves1D.Times","text":"Times(param; ns, Ns)\n\nConstructs a mesh of times, to be used in initial-value problems (see Problem).\n\nArguments\n\nparam is either\n\na NamedTuple containing dt the timestep and T the final time of comuptation; or\na vector of computed times.\n\nOptional keyword arguments\n\nns  : data are stored every ns computations (optional, default = 1).\nNs  : Ns data (in addition to the initial datum) are stored (optional, by default `floor( tfin/dt)).\n\nIf both Ns and ns are given, Ns overrules ns.\n\nReturn values\n\nt=Times(args) is of parametric type and offers\n\nt.Nc: number of computed times (including initial datum);\nt.Ns: number of stored times (including initial datum);\nt.ns: number of computed times between two stored times;\nt.tfin: the final time;\nt.dt: the timestep;\nt.tc : the vector of computed times;\nt.ts: the vector of stored times.\n\n\n\n\n\n","category":"type"},{"location":"library/#Tools","page":"Library","title":"Tools","text":"","category":"section"},{"location":"library/#WaterWaves1D.energy-Tuple{Problem}","page":"Library","title":"WaterWaves1D.energy","text":"energy(pb::Problem;T)\n\nCompute the excess of mass of a solved initial-value problem pb at a given time T.\n\nKeyword argument T is optional, the last computed time is used by default.\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.energydiff-Tuple{Problem}","page":"Library","title":"WaterWaves1D.energydiff","text":"energydiff(pb::Problem;T,rel)\n\nCompute the difference of energy of a solved initial-value problem pb between given time T and initial time.\n\nKeyword argument T is optional, the last computed time is used by default.\n\nIf keyword argument rel=true (default is false), then compute the relative difference (with initial value as reference).\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.interpolate-Tuple{Mesh, Any, Any}","page":"Library","title":"WaterWaves1D.interpolate","text":"interpolate(mesh,vector,x;fast)\n\nInterpolate a vector vector of values on a uniform collocation grid defined by mesh, on collocation points given by x.\n\nIf the collocation points x are regularly spaced and the optional keyword argument fast is set to true (default is false), then the algorithm is faster and uses less allocations, but is less precise.\n\nReturn the vector of values on collocation points.\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.interpolate-Tuple{Mesh, Any}","page":"Library","title":"WaterWaves1D.interpolate","text":"interpolate(mesh,vector;n=2^3)\n\nInterpolate a vector vector of values on a uniform collocation grid defined by mesh.\n\nReturn (new_mesh,new_vector) a new uniform mesh with n times as many values, and the vector of values at these collocation points.\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.mass-Tuple{Problem}","page":"Library","title":"WaterWaves1D.mass","text":"mass(pb::Problem;T)\n\nCompute the excess of mass of a solved initial-value problem pb at a given time T.\n\nKeyword argument T is optional, the last computed time is used by default.\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.massdiff-Tuple{Problem}","page":"Library","title":"WaterWaves1D.massdiff","text":"massdiff(pb::Problem;T,rel)\n\nCompute the difference of excess of mass of a solved initial-value problem pb between given time T and initial time.\n\nKeyword argument T is optional, the last computed time is used by default.\n\nIf keyword argument rel=true (default is false), then compute the relative difference (with initial value as reference).\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.momentum-Tuple{Problem}","page":"Library","title":"WaterWaves1D.momentum","text":"momentum(pb::Problem;T)\n\nCompute the horizontal impulse of a solved initial-value problem pb at a given time T.\n\nKeyword argument T is optional, the last computed time is used by default.\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.momentumdiff-Tuple{Problem}","page":"Library","title":"WaterWaves1D.momentumdiff","text":"momentumdiff(pb::Problem;T,rel)\n\nCompute the difference of horizontal impulse of a solved initial-value problem pb between given time T and initial time.\n\nKeyword argument T is optional, the last computed time is used by default.\n\nIf keyword argument rel=true (default is false), then compute the relative difference (with initial value as reference).\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.solution-Tuple{Problem}","page":"Library","title":"WaterWaves1D.solution","text":"solution(pb::Problem;T,x,interpolation)\n\nGive the solution of a solved initial-value problem at a given time T.\n\nArguments\n\nArgument pb is of type Problem.\nKeyword argument T is optional, the last computed time is returned by default.\nKeyword argument x is optional, if provided the solution is interpolated to the collocation vector x.\nKeyword argument interpolation is optional, if an integer is provided the solution is interpolated on as many collocation points (if true, then the default value 2^3 is chosen).\nKeyword argument raw is optional, if set to true then (U,t) with U the raw data and t the time is returned (default is false).\n\nReturn values\n\nReturn (η,v,x,t) where\n\nη is the surface deformation at collocation points;\nv is the tangential velocity (derivative of the trace of the velocity potential) at collocation points;\nx is the vector of collocation points;\nt the time (first computed time greater or equal to provided T).\n\n\n\n\n\n","category":"method"},{"location":"library/#Load-and-save","page":"Library","title":"Load and save","text":"","category":"section"},{"location":"library/#Base.dump-Tuple{String, Data}","page":"Library","title":"Base.dump","text":"dump(file_name :: String, data :: Data)\n\nSave data to the file with name file_name (and extension \".h5\").\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.dump-Tuple{String, Problem}","page":"Library","title":"Base.dump","text":"dump(file_name  :: String, problem :: Problem)\n\nSave the data of problem to the file with name file_name (and extension \".h5\").\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.dump-Tuple{String, Vector, InitialData}","page":"Library","title":"Base.dump","text":"dump(file_name :: String, x::Vector, init::InitialData )\n\nSave the values of the initial data init at collocation points x to the file with name file_name (and extension \".h5\").\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.load_data!-Tuple{String, Problem}","page":"Library","title":"WaterWaves1D.load_data!","text":"load_data!(file_name :: String, problem :: Problem)\n\nFills problem with raw data extracted from the file with name file_name (and extension \".h5\").\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.load_data-Tuple{String}","page":"Library","title":"WaterWaves1D.load_data","text":"load_data(file_name :: String)\n\nLoad data from the file with name file_name (and extension \".h5\").\n\n\n\n\n\n","category":"method"},{"location":"library/#WaterWaves1D.load_init-Tuple{String}","page":"Library","title":"WaterWaves1D.load_init","text":"load_init(file_name :: String; fast = false)\n\nLoad initial data from  the file with name file_name (and extension \".h5\").\n\nKeyword argument fast is optional (default is false), and corresponds the the keyword argument of the function Init.\n\nReturn an object of type InitialData.\n\n\n\n\n\n","category":"method"},{"location":"problems/#Problems","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"A central object in WaterWaves1D.jl is the Problem structure, which contains all information on a numerically discretized initial-value problem. In practice, a problem is generated as ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = Problem( model, initial, times ; solver, label )","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"where","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"model is related to the (spatially discretized) equation at stake. Built-in models are typically generated as ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"model = MyModel( param ; kwargs )","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"where param is a NamedTuple containing relevant parameters of the model and of the spatial grid,  and kwargs are some optional arguments allowing some choices in the discretization (for instance dealiasing), and a label for future references.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"inital is the couple of initial data. It can be generated for instance using the function Init as  ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"initial = Init( η, v )","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"where η and v are two functions (representing respectively the surface deformation and the derivative of the trace of the velocity potential at the surface). Alternatively, it can also be built from the values of these functions at equally-spaced collocation points.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"times contains relevant parameters of the time integration: in particular the final time  T and the time-step dt. It can be a NamedTuple with these informations or generated via the function Times.\noptionally, the time-solver solver can be provided (built-in solvers are the explicit Euler solver, Euler and Euler_naive, a symplectic Euler solver, EulerSymp, and the explicit Runge-Kutta 4 solver, RK4 and RK4_naive). By default the RK4 solver is used.\noptionally, a string label can be provided for future reference. It is inferred from the model if not provided.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Once it has been built, problem contains the raw data, data (initially just the initial data), in addition to model, initial, times, solver and label. The initial-value problem is then numerically integrated (filling data) with","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"solve!(problem)","category":"page"},{"location":"how-to/#How-to...","page":"How-to...","title":"How to...","text":"","category":"section"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Depth = 2\nPages = [\n        \"how-to.md\"\n        ]","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"WaterWaves1D.jl is meant to be versatile, and integrating new blocks to the package is easy. If you ever do so, please do not hesitate to contact the developers to either get help, or report on your advances.","category":"page"},{"location":"how-to/#build-your-model","page":"How-to...","title":"build your model","text":"","category":"section"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Let us add the linear (Airy) water waves model whose equations are (using the notations introduced here)","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"  leftbeginarrayl\n  _tη+fractanh(sqrtμ D)νsqrtμ D_xv=01ex\n  _tv+_xη=0\n  endarrayright","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"where we use the notation F(D) for the action of pointwise multiplying by the function F in the Fourier space.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"In a dedicated file we write","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"export Airy\nmutable struct Airy <: AbstractModel\n  label   :: String\n  f!      :: Function\n  mapto   :: Function\n  mapfro  :: Function\n\n  # We build our model here.\n\nend","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Our purpose is to provide","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"label, a string used in subsequent informational messages, plots, etc.\nf!, a function to be called in explicit time-integration solvers such as Euler or RK4 (one may provide other functions to be used with other solvers such as EulerSymp)\nmapto, a function which from  a couple (η,v) of type InitialData provides the raw data matrix on which computations are to be executed\nmapfro, a function which from raw data returns (η,v,x) where\nη is the values of surface deformation at collocation points x;\nv is the derivative of the trace of the velocity potential at x.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"To this aim, in place of the commented line, we write","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"function Airy(param::NamedTuple; # param is a NamedTuple containing all necessary parameters\n  label = \"linear (Airy)\"  # using a keyword argument allows the user to supersede the default label.\n   )\n\n  # Set up\n  μ = param.μ\n  if !in(:ν,keys(param)) # set default ν if it is not provided\n    ν = min(1,1/√μ)\n  else\n    ν = param.ν\n  end\n  # Collocation points and Fourier modes\n  m = Mesh(param)\n  x, k = m.x, m.k\n  # Fourier multipliers\n  ∂ₓ\t = 1im * k            # Differentiation\n  ∂ₓF₁ = 1im * tanh.(√μ*k)/(√μ*ν)\n  # Pre-allocation\n  fftη = zeros(Complex{Float64}, m.N)\n  fftv = zeros(Complex{Float64}, m.N)\n\n  # Evolution equations are ∂t U = f(U)\n  function f!(U)\n    fftη .= U[1]\n    fftv .= U[2]\n\n    U[1] .= -∂ₓF₁.*fftv\n    U[2] .= -∂ₓ.*fftη\n  end\n\n  # Build raw data from physical data (discrete Fourier transform)\n  function mapto(data::InitialData)\n    U = [fft(data.η(x)) fft(data.v(x))]\n  end\n\n  # Return physical data `(η,v,x)` from raw data\n  function mapfro(U)\n    real(ifft(U[1])),real(ifft(U[2])),x\n  end\n\n  new( label, f!, mapto, mapfro )\nend","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"A useful tool used in the above was the function Mesh. It takes as argument a NamedTuple containing typically a number of points/modes and the (half-)size of the domain and provides the vector of collocations points and Fourier wavenumbers (see this discussion).","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"The Airy model can now be built as follows","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"using WaterWaves1D\n# include your file\nmodel = Airy((μ=1,L=2π,N=2^8))","category":"page"},{"location":"how-to/#build-your-initial-data","page":"How-to...","title":"build your initial data","text":"","category":"section"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"The simplest way to build an initial data is to use the function Init, which takes as argument either","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"a function η and a function v (in this order);\nan array of collocation points and two vectors representing η(x) and v(x) (in this order);\na mesh (generated with Mesh) and two vectors representing η(mesh.x) and v(mesh.x) (in this order).","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Some relevant initial data (e.g. travelling waves) are built-in; see the library section. You can build your own in the following lines.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"struct Heap <: InitialData\n\tη\n\tv\n\tlabel :: String\n\tinfo  :: String\n\n\tfunction Heap(L)\n\t\tη=x->exp.(-(L*x).^2)\n    v=x->zero(x)\n\t\tinit = Init(η,v)\n\t\tlabel = \"Heap\"\n\t\tinfo = \"Heap of water, with length L=$L.\"\n\n\t\tnew( init.η,init.v,label,info  )\n\tend\nend","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"The corresponding initial data can now be built as follows","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"using WaterWaves1D\n# include your file\ninit = Heap(1)","category":"page"},{"location":"how-to/#build-your-time-solver","page":"How-to...","title":"build your time solver","text":"","category":"section"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"As an example, let us review how the explicit Euler solver, Euler, is built.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"In a dedicated file we write","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"struct Euler <: TimeSolver\n    U1 :: Array\n    label :: String\n\n    function Euler( U :: Array; realdata=nothing )\n        U1 = copy(U)\n        if realdata==true\n            U1 = real.(U1);\n        end\n        if realdata==false\n            U1 = complex.(U1);\n        end\n        new( U1, \"Euler\" )\n    end\nend","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Here, Euler.U1 is a pre-allocated vector which can be used to speed-up calculations, and Euler-label is the string \"Euler\", used for future references. The optional keyword argument realdata allows to specify the type of data which the solver will take as arguments: either complex or real vectors. ","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"We shall now add one method to the function step!, performing the explicit Euler step: that is replacing a vector U with U+dt*f(U) where f is provided by the model at stake.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"export step!\nfunction step!(solver :: Euler,\n                model :: AbstractModel,\n                U  ,\n                dt )\n\n    solver.U1 .= U        # allocate U to U1\n    model.f!( solver.U1 ) # model.f!(U) replaces its argument U with f(U)\n    U .+= dt .* solver.U1 # update U\nend","category":"page"},{"location":"how-to/#access-to-and-manage-your-data","page":"How-to...","title":"access to and manage your data","text":"","category":"section"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Once an initial-value problem problem has been solved (i.e. numerically integrated), the raw data is stored in problem.data.U, which is an array whose elements correspond (in chronological order) to values at the different computed times, problem.times.ts. ","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"using WaterWaves1D #hide\nparam  = ( c = 1.1, ϵ = 1, μ = 1, N  = 2^8, L = 16, T = 1, dt = 0.1)\ninit = SolitaryWhitham(param)\nmodel = Airy(param)\nproblem = Problem( model, init, param )\nsolve!(problem; verbose=false)\n\nproblem.data.U","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Physical data (say at final computed time) can be reconstructed using the model as follows: ","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"η,v,x = problem.model.mapfro(last(problem.data.U))","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"where  η and v are respectively the values of the surface deformation and of the derivative of the trace of the velocity potential at the surface, at collocation points x.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"This procedure is carried out by the function solution, which allows in addition to perform some interpolations (making use of the otherwise helpful function interpolate).","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"η,v,x = solution(problem)","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Using (η,v,x) one can compute other quantities such as the mass, momentum, energy; for instance for the purpose of testing how well these quantities are numerically perserved (when the quantities are first integrals of the considered model). Built-in functions mass, momentum, energy (and massdiff, momentumdiff, energydiff) compute such quantities (or their variation).","category":"page"},{"location":"how-to/#plot-your-data","page":"How-to...","title":"plot your data","text":"","category":"section"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Once (η,v,x) is obtained as above, producing plots is as simple as","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"using Plots\nplot(x, [ η v ], label = [\"η\" \"v\"])","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"One can also plot the amplitude of discrete Fourier coefficients (in semi-log scale) as follows:","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"using FFTW\nk=fftshift(Mesh(x).k);fftη=fftshift(fft(η));fftv=fftshift(fft(v));\nindices = (fftη .!=0) .& (fftv .!=0 )\nplot(k[indices], [ abs.(fftη)[indices] abs.(fftv)[indices] ], yscale=:log10)","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Built-in plot recipes provide convenient ways of producing such plots, and animations.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"plot(problem;var=[:surface,:velocity,:fourier])","category":"page"},{"location":"how-to/#save-and-load-your-data","page":"How-to...","title":"save and load your data","text":"","category":"section"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Thanks to the package HDF5.jl it is possible to save (raw) data to a local file, and then load them for future analyses.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Built-in functions ease the process. Here is a typical example.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Build and solve a problem.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"using WaterWaves1D #hide\nparam  = ( c = 1.1, ϵ = 1, μ = 1, N  = 2^8, L = 16, T = 1, dt = 0.1)\ninit = SolitaryWhitham(param)\nmodel = Airy(param)\nproblem = Problem( model, init, param )\nsolve!(problem; verbose=false)\nnothing","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Save the initial data.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"x = Mesh(param).x\nrm(\"file_name.h5\", force=true) # hide\ndump(\"file_name\", x, init)","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Save the time-integrated (raw) data.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"dump(\"file_name\", problem) # or dump(\"file_name\", problem.data)","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"Reconstruct the problem, without solving it.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"loaded_init = load_init(\"file_name\") # load initial data\nnew_problem = Problem( model, loaded_init, param ) # re-build problem\nload_data!(\"file_name\", new_problem) # incorporate time-integrated data\n\nproblem.data == new_problem.data","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"note: Note\nInitial data are functions. The dump function saves values at some collocation points. Hence the loaded initial data typically differs from the original one by machine epsilon rounding errors.","category":"page"},{"location":"how-to/","page":"How-to...","title":"How-to...","text":"note: Note\nIt is not possible to save models, solvers, or problems. Hence the user needs to store separately the parameters and information required to build them.","category":"page"},{"location":"plot_recipes/#Plot-recipes","page":"Plot recipes","title":"Plot recipes","text":"","category":"section"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"Some recipes are available to visualize computed problems solution. You need to import the package Plots.jl.","category":"page"},{"location":"plot_recipes/#Surface-deformation-and-velocity","page":"Plot recipes","title":"Surface deformation and velocity","text":"","category":"section"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"using WaterWaves1D #hide\nusing Plots\n\nparam = ( μ = 1, ϵ = 1/4, N = 2^10, L = 10, T = 5, dt = 0.01 )\nz(x) = exp.(-abs.(x).^4)\nv(x) = zero(x)\ninit = Init(z,v)\n\nmodel0 = WaterWaves(param; tol = 1e-15)  # The water waves system\nmodel1 = Airy(param)                     # The linear model (Airy)\nmodel2 = WWn(param;n=2,dealias=1,δ=1/10) # The quadratic model (WW2)\n\nproblem0 = Problem(model0, init, param);\nproblem1 = Problem(model1, init, param);\nproblem2 = Problem(model2, init, param);\n\nsolve!([problem0 problem1 problem2]; verbose=false);\n\n\nplot(problem0)\nplot!(problem1)\nplot!(problem2; var = :surface, legend = :bottomright)","category":"page"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"plot([problem0, problem1, problem2]; var = :velocity, legend = :bottomright)","category":"page"},{"location":"plot_recipes/#Differences","page":"Plot recipes","title":"Differences","text":"","category":"section"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"plot([problem0, problem1], var = :difference)\nplot!([problem0, problem2], var = :difference)","category":"page"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"plot([(problem0, problem1), (problem0, problem2)])","category":"page"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"plot([(problem0, problem1), (problem0, problem2)], var = :difference_velocity)","category":"page"},{"location":"plot_recipes/#Fourier-coefficients","page":"Plot recipes","title":"Fourier coefficients","text":"","category":"section"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"using Plots\nusing WaterWaves1D #hide\n\nη(x) = exp.(-x.^2)\nv(x) = zero(x)   \ninit = Init(η,v)\n\nparam1 = ( ϵ = 1/4, μ = Inf, N = 2^8, L = 2*π, T = 5, dt = 0.001 )\n\nproblem1 = Problem( WWn(param1, dealias = 1), init, param1 ) \n\nparam2 = ( ϵ = 1/4, μ = Inf, N = 2^9, L = 2*π, T = 5, dt = 0.001 )\n\nproblem2 = Problem( WWn(param2, dealias = 1), init, param2 ) \n\nsolve!([problem1, problem2])\n\nplot([problem1, problem2]; T=5, var = :fourier)","category":"page"},{"location":"plot_recipes/#Subplots","page":"Plot recipes","title":"Subplots","text":"","category":"section"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"l = @layout [a ; b; c]\np1 = plot(problem1, var = :surface)\np2 = plot(problem1, var = :velocity)\np3 = plot(problem1, var = :fourier)\nplot(p1, p2, p3, layout = l, \n\t titlefontsize=10, \n\t labelfontsize=8)","category":"page"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"plot(problem1, var = [:surface,:velocity,:fourier])","category":"page"},{"location":"plot_recipes/#Interpolation","page":"Plot recipes","title":"Interpolation","text":"","category":"section"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"x̃ = LinRange(-5, 5, 128)\nplot(problem2, x = x̃, shape = :circle)","category":"page"},{"location":"plot_recipes/#Plots-at-different-times","page":"Plot recipes","title":"Plots at different times","text":"","category":"section"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"plot(problem1, T = 0, label = \"t = 0\")\nfor t in 1:5\n    plot!(problem1, T = t, label = \"t = $t\")\nend\ntitle!(\"surface deformation for t ∈ [0,5]\")","category":"page"},{"location":"plot_recipes/#Create-animation","page":"Plot recipes","title":"Create animation","text":"","category":"section"},{"location":"plot_recipes/","page":"Plot recipes","title":"Plot recipes","text":"@gif for t in LinRange(0,param1.T,100)\n    plot(problem1, T = t)\n    ylims!(-0.5, 1)\nend","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Depth = 4\nPages = [ \"background.md\"  ]","category":"page"},{"location":"background/#Water-waves","page":"Background","title":"Water waves","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The propagation of waves at the surface of a layer of water is typically modelled using the incompressible Euler equations inside the fluid domain, and suitable boundary conditions at the boundaries (accounting for the impermeable bottom and the free surface).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In an idealized situation where the only external force acting on the fluid is due to the (constant) vertical gravity acceleration, that the fluid is homogeneous and the flow is potential (that is irrotational), the system can be written in closed form as two evolution equations.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Restricting to unidimensional waves (horizontal dimension d=1) in a domain without horizontal boundaries, assuming that the free surface can be described as the graph of a function which never touches the bottom (that is, non-cavitation) neglecting surface tension effects, assuming constant atmospheric pressure at the free surface and free slip boundary condition at the flat bottom, the equations in dimensionless variables read as follows (following notations in Lannes, Duchêne).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1μν G^μϵηψ=01ex\n  _tψ+η+fracϵ2ν(_xψ)^2-tfracϵμ2νfrac(frac1μ G^μϵηψ+ϵ(_xη)(_xψ))^21+μϵ²(_xη)^2=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where, by definition,","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"G^μϵηψ=big(_zPhi-μϵ(_xη)(_xΦ)big)bigvert_z=ϵη","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with Φ being the unique solution to the elliptic boundary value problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"leftbeginarrayll\nμ _x^2 Φ + _z^2 Φ=0 text in  (xz)    -1zϵη(x)  \n Φ= ψ  text on  (xz)    z=ϵη(x) \n_z Φ=0  text on  (xz)    z=-1 \nendarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In the above formula,","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"txz represent respectively the (rescaled) time, horizontal and vertical space variables.\nη represents the surface deformation: the free surface may be parametrized as (xz)   z=ϵη(x).\nψ is the trace of the velocity potential at the surface. In models we generally prefer to use v=ₓψ as the second unknown, since ψ is not necessarily decaying at (spatial) infinity even in finite-energy situations.\nϵ is the nonlinearity dimensionless parameter, defined as the ratio of the maximal amplitude of the wave to the depth of the layer.\nμ is the shallowness dimensionless parameter, defined as the square of the ratio of the depth of the layer to the typical horizontal wavelength of the flow.\nν is a scaling parameter: in shallow water situations one typically sets ν=1 while in deep water situations it is wise to set ν=1sqrtμ. In the latter case, ϵsqrtμ being the steepness of the wave plays an important role. Especially, taking formally the limit μ one obtains the infinite-depth situation where the wave steepness is the only remaining parameter.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"While the above formulation (due to Zakharov and Craig and Sulem) is very elegant, it is not directly suitable for efficient numerical simulations, due to the costly time-dependent elliptic problem involved in the Dirichlet-to-Neumann operator, G^μ. In our unidimensional framework, it is possible to make use of conformal mapping so as to rewrite the system using only pointwise operations or Fourier multipliers (that is pointwise operations in Fourier space). This allows, by means of the Fast Fourier Transform (FFT) and its inverse (IFFT), to provide a very efficient strategy for the numerical simulation of the water waves system. This strategy has been described for instance in Dyachenko et al. and Choi and Camassa.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The resulting code is WaterWaves.","category":"page"},{"location":"background/#Models","page":"Background","title":"Models","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Because the above method is relatively recent (in comparison with early studies on water waves), imperfect (it suffers from \"anti-resolution\" for large-amplitude waves: the location of gridpoints spread out near wave crests, which in practice may demand the use of a very large number of modes to resolve the flow accurately), and restricted to unidimensional waves, many simplified models have been introduced in the literature. It is the aim of this package to provide a home for some of them.","category":"page"},{"location":"background/#Shallow-water-models","page":"Background","title":"Shallow water models","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Shallow water models are expected to provide valid approximation to the water waves system for small values of the shallowness parameter, μ1 (in this case, ν=1).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Many of these models are derived and discussed in Duchêne.","category":"page"},{"location":"background/#The-Saint-Venant-system","page":"Background","title":"The Saint-Venant system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The Saint-Venant system is one of the oldest model for the propagation of water waves. It reads","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x((1+ϵη)v)=01ex\n  _tv+_xη+ϵv_xv=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Notice that the parameter μ has disappeared: the Saint-Venant system is the order-zero shallow water model for water waves.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is SaintVenant.","category":"page"},{"location":"background/#The-Boussinesq-systems","page":"Background","title":"The Boussinesq systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The abcd-Boussinesq systems refers to the full class of equations described by Bona, Chen and Saut","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x((1+ϵη)u)+a_x^3u-b_x^2_tη=01ex\n  _tu+_xη+ϵu_xu+c_x^3η-d_x^2_tu=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where abcd can be freely chosen as long as they satisfy a+b+c+d=13.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code Boussinesq is restricted to the so-called Hamiltonian case, b=d, and c=0.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Indeed, in that case, one may genuinely interpret v=u-d_x^2u as an approximation to _xψ, the derivative of the trace of the velocity potential at the surface, and write the system as evolution equations for the variables (ηv):","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x((1+a_x^2)(1-b_x^2)^-2v + ϵ(1-b_x^2)^-1 (η (1-b_x^2)^-1v))=01ex\n  _tv+_xη+tfracϵ2_x(((1-b_x^2)^-1v)^2) =0\n  endarrayright","category":"page"},{"location":"background/#The-Whitham-Boussinesq-systems","page":"Background","title":"The Whitham-Boussinesq systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The Whitham-Boussinesq systems can be viewed as modified Boussinesq systems in view of fully recovering the dispersive properties of the water waves system. In other words, in the linear framework, that is setting ϵ=0, the model coincides with the linearized water waves system.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Specifically, we consider systems of the form","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x(F_1^μv + ϵ F_2^μ (η F_2^μv))=01ex\n  _tv+_xη+tfracϵ2_x((F_2^μv)^2) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with F_1^μ=fractanh(sqrtμ D)sqrtμ D, and F_2^μ=(F_1^μ)^α (here we use the notation F(D) for the action of pointwise multiplying by the function F in the Fourier space). The case α = 1 has been introduced by Dinvay, Dutykh and Kalisch, more general situations have been studied by Emerald.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is WhithamBoussinesq.","category":"page"},{"location":"background/#The-Green-Naghdi-system","page":"Background","title":"The Green-Naghdi system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The (Serre-)Green-Naghdi system (Serre, Su and Gardner, Green and Naghdi) is sometimes called \"fully nonlinear Boussinesq system\" and is expected to provide a better approximation when the parameter ϵ is large.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"One of its many formulations is","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xbig( h ubig)=01ex\n  _tv+_xbig(η+ϵ uv - tfracϵ2u^2-tfracμϵ2 (h_xu)^2big) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, and u the layer-averaged horizontal velocity obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" hu -tfracμ3_x( h^3 _xu) = hv","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is SerreGreenNaghdi.","category":"page"},{"location":"background/#The-square-root-depth-system","page":"Background","title":"The square-root depth system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The \"√D\" system proposed by Cotter, Holm and Percival can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xbig( h ubig)=01ex\n  _tv+_xbig(η+tfracϵ2v^2+tfracμϵ6h^2 (_x(hu))^2big) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, and u is obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" u -tfracμ3_x( h^-1 _x(hu)) = v","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is SquareRootDepth.","category":"page"},{"location":"background/#The-\"non-hydrostatic\"-system","page":"Background","title":"The \"non-hydrostatic\" system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The \"non-hydrostatic\" system proposed by Bristeau, Mangeney, Sainte-Marie and Seguin can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xbig( h ubig)=01ex\n  _tv+_xbig(η+tfracϵ2v^2+tfracμϵ2 ( w_x^2(hu) + _x^2( hu w ) + ϵ (_xη)(_xw)u )big) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, w=-(h ₓu)2 and u is obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" hu -tfracμ4_x( h^3 _xu) = hv","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is NonHydrostatic.","category":"page"},{"location":"background/#The-Whitham-Green-Naghdi-system","page":"Background","title":"The Whitham-Green-Naghdi system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The Whitham-Green-Naghdi system proposed by Duchêne, Israwi and Talhouk. can be viewed as a modified Green-Naghdi system in view of fully recovering the dispersive properties of the water waves system. In other words, in the linear framework, that is setting ϵ=0, the model coincides with the linearized water waves system.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xbig( h ubig)=01ex\n  _tv+_xbig(η+ϵ uv - tfracϵ2u^2-tfracμϵ2 (h F_0^μ_xu)^2big) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, and u the layer-averaged horizontal velocity obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"hu -tfracμ3F_0^μ_x( h^3 F_0^μ_xu) = hv","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with F_0^μ=sqrt3((F_1^μ)^-1(D) - 1)D where F_1^μ=fractanh(sqrtμ D)sqrtμ D (here we use the notation F(D) for the action of pointwise multiplying by the function F in the Fourier space).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is WhithamBoussinesq.","category":"page"},{"location":"background/#The-Isobe-Kakinuma-systems","page":"Background","title":"The Isobe-Kakinuma systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The Isobe-Kakinuma model is a hierarchy of models proposed by Isobe, depending on the rank N and the parameters (p_0p_1p_N)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xleft( sum_j=0^Ntfrach^p_j+1p_j+1_xϕ_j right)=01ex\n  _tv+_xleft( η\n  +ϵ left( sum_i=0^Np_ih^p_i-1ϕ_i right)_xleft( sum_j=0^Ntfrach^p_j+1p_j+1_xϕ_j right)\n  +tfracϵ2left( sum_j=0^Nh^p_j_xϕ_jright)^2\n  +tfracϵ2μ left( sum_j=0^Np_jh^p_j-1ϕ_jright)^2 right) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, and (ϕ₀ϕ₁ϕ_N) are obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\nsum_j=0^Nh^p_jϕ_j =ψ1ex\n-h^p_i _xleft(sum_j=0^Ntfrach^p_j+1p_j+1_xϕ_j right)\n+ _xleft(sum_j=0^Ntfrach^p_i+p_j+1p_i+p_j+1_xϕ_j right)\n-tfrac1μ sum_j=0^N tfracp_ip_jp_i+p_j+1ϕ_j=0 quad (forall i1N)\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code IsobeKakinuma is (for now) limited to the case N=1 and (p₀p₁)=(02).","category":"page"},{"location":"background/#Small-steepness-models","page":"Background","title":"Small steepness models","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Small-steepness models rely on the smallness of the steepness dimensionless parameter, ϵsqrtμ1, and may be valid in shallow water as well as deep water configurations.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In what follows we use the notation F(D) for the action of pointwise multiplying by the function F in the Fourier space. Specifically,","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"T^μ=-rm itanh(sqrtμ D)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"is the \"Tilbert transform\" (related to the Hilbert transform, the latter arising in the infinite layer configuration, μ=).","category":"page"},{"location":"background/#The-Airy-equations","page":"Background","title":"The Airy equations","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The simplest small-steepness model is the linear Airy water waves obtained by setting ϵ=0 in the water waves system:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μv =01ex\n  _tv+_xη=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where we denote v=_xψ the derivative of the trace of the velocity potential at the surface.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is Airy.","category":"page"},{"location":"background/#The-spectral-systems","page":"Background","title":"The spectral systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Dommermuth and Yue, West et al., and Craig and Sulem have proposed a hierarchy of systems based on a \"spectral\" expansion, which can be interpreted through the Taylor expansion of the Dirichlet-to-Neumann, G^μϵηψ, with respect to the surface deformation variable:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"G^μϵηψ=G^μ0ψ + ϵ (D_η G^μ0)(ϵη)ψ + ϵ^2 (D_η^2 G^μ0)(ϵηϵη)ψ + ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The first nonlinear system of the hierarchy, incorporating only quadratic nonlinearities, is","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μv  + tfracϵν _xbig(η v +  T^μ(η T^μ v)big) =01ex\n  _tv+_xη+fracϵ2ν_xbig( v^2-(T^μv)^2big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where we denote v=_xψ the derivative of the trace of the velocity potential at the surface.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Higher order systems can be constructed using recursive formula. Explicit expressions up to quintic nonlinearities are given in Choi.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is WWn.","category":"page"},{"location":"background/#The-rectified-spectral-systems","page":"Background","title":"The rectified spectral systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"It turns out the spectral models above suffer from spurious instabilities; see Ambrose, Bona and Nicholls.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Duchêne and Melinand proposed a \"rectified\" quadratic model:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μv  + tfracϵν _xbig((J^δη) v +  T^μ((J^δη) T^μ v)big) =01ex\n  _tv+_xη+fracϵ2ν_xJ^δbig( v^2-(T^μv)^2big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with J^δ=J_0(δD) where J_0(k) approaches 1 for small wavenumbers, k, and approaches 0 for large wavenumbers; and the parameter δ can be freely chosen, but is typically of the size of tfracϵν. In the associated code, WWn, one has by default","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"J_0(k)=min(11k)","category":"page"},{"location":"background/#The-Matsuno-system","page":"Background","title":"The Matsuno system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The model introduced by Matsuno is","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μu  + tfracϵν _x(η u) +  tfracϵν T^μ(η _x T^μ u) =01ex\n  _tu+big(1-ϵsqrtμ T^μ_xηbig)_xη+fracϵ2ν_xbig( u^2big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where u=_xψ-ϵsqrtμ(T^μ_xψ)(_xη) represents the horizontal velocity at the free surface.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated codes are Matsuno, and Matsuno_fast for a less human-readable but more efficient version.","category":"page"},{"location":"background/#The-modified-Matsuno-system","page":"Background","title":"The modified Matsuno system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"In view of ensuring the stability of the equations, Duchêne and Melinand proposed a modified Matsuno system:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μu  + tfracϵν _x(η u) +  tfracϵν T^μ(η _x T^μ u) =01ex\n  _tu+expbig(-ϵsqrtμ T^μ_xηbig)_xη+fracϵ2ν_xbig( u^2big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated codes is modifiedMatsuno.","category":"page"},{"location":"background/#The-Akers-Nicholls-system","page":"Background","title":"The Akers-Nicholls system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The model introduced in Akers and Nicholls (see also Cheng, Granero-Belinchón, Shkoller and Milewski) can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x m=01ex\n  _tm-tfrac1sqrtμ ν T^μbig(η+fracϵν(L^μ m)^2big)+fracϵνbig(η_xη+T^μ(η _x T^μ η)big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with notations as above, L^μ=fracνsqrtμ Dtanh(sqrtμ D) and where m=-frac1sqrtμ ν T^μψ  + fracϵν big(η _xψ +  T^μ(η T^μ _xψ)big) represents the vertically integrated horizontal momentum.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated codes is AkersNicholls, and AkersNicholls_fast for a less human-readable but more efficient version.","category":"page"},{"location":"background/#Mass,-momentum,-energy","page":"Background","title":"Mass, momentum, energy","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Solutions to the water waves equations preserve along time (among other integrals of motion listed by Benjamin and Olver)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"the excess of mass,","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"int η(tx) rm dx ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"the momentum (or rather the horizontal impulse),","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"int (η _xψ)(tx) rm dx ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"the total energy,","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"frac12 int (η^2 + tfrac1μν ψ G^μϵηψ)(tx) rm dx ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Such is also the case for solutions to all models cited above using as velocity variable v=_xψ (with analogous formula).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The numerical discretization of these preserved quantities, coded in mass, momentum, energy (and massdiff, momentumdiff, energydiff) provide valuable insights at the precision of a computed numerical solution.","category":"page"},{"location":"background/#Pseudospectral-methods","page":"Background","title":"Pseudospectral methods","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Although this is not imperative of the package, all the codes mentioned above use Fourier-based pseudospectral methods for spatial discretization. This method is particularly suitable for data which are either periodic or decaying at infinity (in which case the function at stake is considered as periodic on a sufficiently large period), and fairly regular. In this framework one approaches 2L-periodic functions by finite Fourier sums of the form (assuming N even)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"u(tx)sum_k=-N2^N2-1 a_k(t) e^rm i tfracπLk x","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"and seek a system of ordinary differential equations on the coefficients a_k(t) (which are then discretized in time by your favorite time solver).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In practice, given the values (u(x_j))_j0N-1 at the regularly spaced collocation points x_j= -L+2jtfracLN, one uses the discrete Fourier transform (computed efficiently with a Fast Fourier transform (FFT)) to deduce the corresponding coefficients a_k. Hence the coefficients are related to the coefficients of the (infinite) Fourier series","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"u(tx)=sum_k=-^ c_k(t) e^rm i tfracπLk x","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"through the relation","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"a_k(t) = sum_ℓinmathbbZ c_k+ℓN(t)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Hence each of the coefficients a_k encompasses a full series of Fourier coefficients, which is unavoidable since e^rm i tfracπLk x and e^rm i tfracπL(k+ℓN) x are indistinguishable on the gridpoints xx_0x_N-1: this is called aliasing. Yet for smooth functions, Fourier coefficients rapidly decrease, and the error between the finite spectral decomposition and the infinite Fourier decomposition can often be made immaterial (that is to the order of machine precision rounding errors) when choosing a sufficient large number of modes, N.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"When using the finite spectral decomposition, the action of Fourier multipliers, and in particular spatial differentiation, is performed exactly (that is up to machine precision rounding errors) through corresponding multiplication on the discrete coefficients a_k, and only nonlinear contributions require some attention. The simplest way to approximately compute products (or any pointwise operations in the space variable) is by performing pointwise operations on values at collocation points which are obtained from the discrete coefficients using discrete inverse Fourier transform. For the sake of discussion, consider","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" u^2(x_jt)  big(sum_k=-N2^N2-1 a_k(t) e^rm i tfracπLk x_jbig)^2\n = sum_m=-N2^N2-1sum_n=-N2^N2-1 a_m a_n e^rm i tfracπL(m+n) x_j","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"One infers","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"u^2(x_jt)  sum_k=-N2^N2-1 b_k(t) e^rm i tfracπLk x_j qquad b_k = sum_m+nin k-Nkk+Na_m a_n","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In the above formula for b_k, some of the summands are spurious effects from aliasing, which sometimes contribute to numerical instabilities. In order to suppress such terms the so-called dealiasing consists in adding a sufficient number of modes with coefficients set to zero (in practice one often uses ideal low-pass filters, that is set to zero extreme modes, so as to always work with vectors with a fixed given length). The so-called Orszag's 3/2 rule states that, in the presence of quadratic nonlinearities, padding 3/2 modes (or zero-ing 1/3 modes) is sufficient to discard all spurious aliasing contributions, and provides in particular a Galerkin approximation since the error is orthogonal to all expansion functions.","category":"page"},{"location":"#WaterWaves1D.jl-documentation","page":"Home","title":"WaterWaves1D.jl documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WaterWaves1D.jl is a Julia package providing a framework to study and compare several models for the propagation of unidimensional surface gravity waves (a.k.a. \"water waves\").","category":"page"},{"location":"","page":"Home","title":"Home","text":"Several models are already implemented, including (but not limited to) the so-called water waves system, its truncated spectral expansion, the Green-Naghdi system, the Matsuno system, and so on. You may easily add your favorite one to the gang: see the how-to guide.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the Pkg REPL by pressing ] from the Julia REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.8) pkg> add WaterWaves1D","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once installed, load the package with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using WaterWaves1D","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A simple example is documented here. More advanced examples can be found in the package's examples and notebooks folders.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WaterWaves1D.jl is being developed by Vincent Duchêne and Pierre Navaro.","category":"page"},{"location":"#Documentation-contents","page":"Home","title":"Documentation contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Depth = 3\nPages = [\n        \"index.md\",\n        \"background.md\",\n        \"problems.md\",\n        \"how-to.md\",\n        \"example.md\",\n        \"plot_recipes.md\",\n        \"library.md\"\n        ]","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In this example we shall observe the disintegration of a heap of water using the water-waves system as well as a second-order small-steepness model.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"More advanced examples can be found in the package's examples and notebooks section.","category":"page"},{"location":"example/#Set-up-the-initial-value-problem","page":"Example","title":"Set up the initial-value problem","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"First we define parameters of our problem.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using WaterWaves1D\n\nparam = (\n    # Physical parameters. Variables are non-dimensionalized as in Lannes, The water waves problem, isbn:978-0-8218-9470-5\n    μ  = 1,     # shallow-water dimensionless parameter\n    ϵ  = 1/4,   # nonlinearity dimensionless parameter\n    # Numerical parameters\n    N  = 2^10,  # number of collocation points\n    L  = 10,    # half-length of the numerical tank (-L,L)\n    T  = 5,     # final time of computation\n    dt = 0.01,  # timestep\n                );","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now we define initial data solver (the \"heap of water\"). The function Init may take either functions, or vectors (values at collocation points) as arguments.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"z(x) = exp.(-abs.(x).^4); # surface deformation\nv(x) = zero(x);     # zero initial velocity\ninit = Init(z,v);         # generate the initial data with correct type","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Then we build the different models to compare (see WaterWaves and WWn).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"WW_model=WaterWaves(param) # The water waves system\nWW2_model=WWn(param;n=2,dealias=1,δ=1/10) # The quadratic model (WW2)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Finally we set up initial-value problems. Optionally, one may specify a time solver to Problem, by default the standard explicit fourth order Runge Kutta method is used.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"WW_problem=Problem(WW_model, init, param) ;\nWW2_problem=Problem(WW2_model, init, param) ;","category":"page"},{"location":"example/#Solve-the-initial-value-problem","page":"Example","title":"Solve the initial-value problem","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Solving the initial-value problems is as easy as solve!.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"solve!([WW_problem WW2_problem];verbose=false);","category":"page"},{"location":"example/#Generate-graphics","page":"Example","title":"Generate graphics","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Plot solutions at final time.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Plots\nplot([WW_problem, WW2_problem])","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Generate an animation.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"@gif for t in LinRange(0,param.T,100)\n    plot([WW_problem, WW2_problem], T = t)\n    ylims!(-0.5, 1)\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"See the plot recipes for many more plotting possibilities.","category":"page"}]
}
